<html lang="en">
<head>
<title>Component Model</title>
<style>
span.shadow-boundary {
    color: Gray;
}

span.event-ancestor, span.first-divergent-boundary {
    color: DarkRed;
}

span.event-ancestor > em {
    background-color: DarkRed;
    color: White;
    font-style: normal;
    border-radius: 1em;
    padding: 0 0.35em;
}

span.lowest-common-boundary {
    color: Green;
}
</style>
</head>

<body class="draft">

<header>

<h1>Component Model</h1>
<p>Draft Version</p>

</header>

<h2>Status</h2>

<p class="warning">This is a work-in-progress!</p>

<p>TODO: status summary</p>

<h2>Shadow DOM</h2>

<h2><a name="overview">Overview</a></h2>

<p>
The component model aims to allow authors to define richly structured widgets that can simply be dropped into web pages. In order for them to be usable however, their internal structure should be hidden from the normal
DOM tree. In other words, a component should look and behave exactly like a built-in HTML element would.
</p>
<p>
The <dfn id="shadowdom" title="shadow DOM">shadow DOM</dfn> is the mechanism by which the internal structure of a component is hidden.
It is a separate tree attached to the <dfn id="hostelement" title="host element">host element</dfn>, rooted by a <code><a href="#shadowroot">ShadowRoot</a></code> node.
</p>
<p>
A parent class <code><a href="#treescope">TreeScope</a></code> encapsulates the commonality between
<code><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#documents">Document</a></code> nodes and
<code><a href="#shadowroot">ShadowRoot</a></code> nodes.
</p>

<object data="../../assets/images/shadowdom.svg" width=500 height=200></object>

<h3 id="treescope">TreeScope</h3>

<p>
Similar to <code><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#documents">Document</a></code> nodes,
a <code><a href="#shadowroot">ShadowRoot</a></code> node needs to govern the nodes it contains.
For example, because components are replicated wherever they are instantiated every shadow DOM needs to register the IDs of elements in the tree separately.
The same goes for scripts that run within a component.
</p>
<p>
For a clean interface, those functionalities are moved to a sperate class <code><a href="#treescope">TreeScope</a></code>,
which acts as base class for <code><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#documents">Document</a></code>
and <code><a href="#shadowroot">ShadowRoot</a></code>:
</p>

<pre class="idl">
interface <a href="#treescope">TreeScope</a> {
    readonly attribute <a href="#TreeScope">TreeScope</a>?  <a href="#treescope.parenttreescope">parentTreeScope</a>;
<!--
    readonly attribute <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#htmlcollection">HTMLCollection</a>   <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#dom-document-images">images</a>;
    readonly attribute <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#htmlcollection">HTMLCollection</a>   <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#dom-document-embeds">embeds</a>;
    readonly attribute <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#htmlcollection">HTMLCollection</a>   <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#dom-document-plugins">plugins</a>;
    readonly attribute <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#htmlcollection">HTMLCollection</a>   <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#dom-document-links">links</a>;
    readonly attribute <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#htmlcollection">HTMLCollection</a>   <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#dom-document-forms">forms</a>;
    readonly attribute <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#htmlcollection">HTMLCollection</a>   <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#dom-document-scripts">scripts</a>;
-->
    <a href="http://www.w3.org/TR/domcore/#element">Element</a>?        <a href="http://www.w3.org/TR/domcore/#dom-document-getelementbyid">getElementById</a>(in DOMString elementId);
    <a href="http://www.w3.org/TR/domcore/#nodelist">NodeList</a>        <a href="http://www.w3.org/TR/domcore/#dom-document-getelementsbyclassname">getElementsByClassName</a>(in DOMString tagName);
    <a href="http://www.w3.org/TR/domcore/#nodelist">NodeList</a>        <a href="http://www.w3.org/TR/domcore/#dom-document-getelementsbytagname">getElementsByTagName</a>(in DOMString className);
    <a href="http://www.w3.org/TR/domcore/#nodelist">NodeList</a>        <a href="http://www.w3.org/TR/domcore/#dom-document-getelementsbytagnamens">getElementsByTagNameNS</a>(DOMString? namespace, DOMString localName);
}
</pre>

<p class="issue">
It would be nice to also add <code><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#dom-document-getelementsbyname">getElementsByName</a></code>,
but this is located within the <code><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#htmldocument">HTMLDocument</a></code> interface.
Note that also <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#documents-in-the-dom">the HTML5 spec</a> defines <code>HTMLDocument</code> to no longer be derived from document.
</p>

<p>
<dfn id="treescope.parenttreescope" title="parentTreeScope">parentTreeScope</dfn>: returns the <code><a href="#treescope">TreeScope</a></code> that contains this <code><a href="#treescope">TreeScope</a></code>.
</p>
<p>

<p class="issue">
<code><a href="#treescope.parenttreescope">parentTreeScope</a></code> is a natural part of a <code><a href="#treescope">TreeScope</a></code>.

<h3>ShadowRoot</h3>

<p>The root of a shadow DOM is represented by the <code><a href="#shadowroot">ShadowRoot</a></code> object:

<pre class="idl">
<a href="#shadowroot">[Constructor(in HTMLElement element) raises(DOMException)]</a>

interface <a href="#shadowroot">ShadowRoot</a> : <a href="#treescope">TreeScope</a> {
    <del>attribute bool <a href="#shadowroot.applyauthorsheets">applyAuthorSheets</a>; </del>
    readonly attribute Element <a href="#shadow-host-attribute">shadowHost</a>;
}
</pre>

<p>
The <code>element</code> parameter in the <a href="#shadow-root-constructor">ShadowRoot constructor</a> is an <a href="http://www.w3.org/TR/domcore/#element" title="DOM Core Element object">Element</a> that will be hosting this instance.
If the element is already hosting a <span class=ref>shadow DOM subtree</span>, a <a href="http://www.w3.org/TR/domcore/#dom-domexception-no_modification_allowed_err">NO_MODIFICATION_ALLOWED_ERR</a> DOM Exception is raised.
</p>

<p>
<del>
The <dfn id="shadowroot.applyauthorsheets" title="shadowroot.applyauthorsheets">applyAuthorSheets</dfn> attribute indicates whether or not rules in <a href="http://www.w3.org/TR/CSS2/cascade.html">author style sheets</a>
associated with the element's document apply to the <span class=def>shadow DOM subtree</a>.
</del>
</p>

<p>
The <dfn id="shadowroot.shadowhost" title="shadow-host-attribute">shadowHost</dfn> attribute refers back to the element that is hosting this <span class=ref>shadow root</span>.
</p>

<p class="issue">
<code><a href="#shadowroot.shadowhost">shadowHost</a></code> is a natural part of a <code><a href="#shadowroot">ShadowRoot</a></code>.</p>

<!--
<p>
The component model extends the <a href="http://www.w3.org/TR/domcore/#element" title="DOM Core Element object">Element</a> as follows:
</p>

<pre class="idl">
[Supplemental]
interface Element {
    attribute String <a href="#pseudo-attribute">pseudo</a>;
}
</pre>

<p>
The <dfn id="pseudo-attribute" title="pseudo-attribute">pseudo</dfn> attribute allows setting a <a href="http://www.w3.org/TR/CSS2/selector.html#pseudo-element-selectors">CSS pseudo-element value</a> on an element and roughly corresponds to functionality of the <a href="http://dev.w3.org/2006/xbl2/#the-pseudo-attribute">XBL2 pseudo attribute</a>.

-->
<!-- TODO(dominicc): should reproduce the IDENT grammar here; the list
     of identifiers are from the CSS3 draft but the links are to CSS2,
     that has to be rationalized. -- >
<!--
The value must either be <code>null</code> or a string that matches the <code>IDENT</code> production of the <a href="http://www.w3.org/TR/CSS2/grammar.html">CSS grammar</a>,
with the exception that the names defined by CSS for <a href="http://www.w3.org/TR/CSS2/selector.html#pseudo-class-selectors">pseudo class selectors</a> and
<a href="http://www.w3.org/TR/CSS2/selector.html#pseudo-element-selectors">pseudo element selectors</a> are not valid.
For example: <code>active</code>, <code>after</code>, <code>before</code>, <code>checked</code>, <code>disabled</code>, <code>empty</code>, <code>enabled</code>, <code>first-child</code>, <code>first-letter</code>,
<code>first-line</code>, <code>first-of-type</code>, <code>focus</code>, <code>hover</code>, <code>indeterminate</code>, <code>lang</code>, <code>last-child</code>, <code>last-of-type</code>, <code>link</code>,
<code>not</code>, <code>nth-child</code>, <code>nth-last-child</code>, <code>nth-last-of-type</code>, <code>nth-of-type</code>, <code>only-child</code>, <code>only-of-type</code>, <code>root</code>, <code>target</code>, <code>visited</code>.
</p>
-->

<h4><code><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/semantics.html#the-style-element">style</a></code> elements</h4>

<p>
The <code>ShadowRoot</code> is a legal parent for a <code><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/semantics.html#the-style-element">style</a></code> element.
</p>

<h2>Events in the Component Model</h2>

<p class="issue">boundless ancestor</span> -- need better term.</li>

<h3>Event Retargeting</h3>

<p>
When an event is fired in a shadow DOM subtree, it either <em>escapes</em> out of the shadow tree during the capture, target, bubble, or default phases or it <em>is stopped</em> at the <span class=ref>shadow boundary</span>.
</p>
<p>
To help with algorithm description, let's define the direction walking the ancestors of a node as <dfn>up</dfn> when traversing from child to parent, and <dfn>down</dfn> when traversing from parent to child.
In the context of events-related algorithms, all ancestor traversal crosses <span class=ref>shadow boundaries</span>.
</p>
<p>
In the cases where event escapes the shadow tree, the event is <span class=ref>retargeted</span> to ensure that the original target-related information on the event object does not reveal information
about the <span class=ref>shadow DOM subtree</span> beyond the boundary. Event retargeting is a process of computing a <dfn>relative target</dfn> for each <span class=ref>ancestor</span> of the node at which the event is dispatched.
</p>
<p>
The following <a href="#retargeting-algorithm">retargeting algorithm</a> must be used to determine relative targets:
</p>

<div class="algorithm"><dfn id="retargeting-algorithm" title="Retargeting Algorithm">Retargeting Algorithm</dfn>
<ol>
    <li>Set the relative target of the node at which event is fired to the node itself.</li>
    <li>For each ancestor walking <span class=ref>up</span> starting with the node's parent, compute its <span class=ref>relative target</span>:</p>
        <dl>
            <dt>If the node is a <span class=ref>shadow boundary</span>:
            <dd>Skip it.

            <dt>If the previous node was a <span class=ref>shadow boundary</span>:
            <dd>Make the node its own <span class=ref>relative target</span>.

            <dt>Otherwise:
            <dd>Use the previous node's <span class=ref>relative target</span>.</li>
        </ol>
    </li>
</ol>
</div>

<p>
The retargeting process must occur prior to dispatch of an event.
</p>

<p>
At the time of event dispatch, for capturing, target, and bubbling phases, <code>Event</code> object's <code>target</code> and <code>currentTarget</code>
must be set to the <span class=ref>relative target</span> that was computed for the node along the capturing and bubbling flow.
</p>

<p>
The event must not be retargeted during the default phase of dispatch.
</p>

<p>
Upon completion of the event dispatch, the <code>Event</code> object's <code>target</code> and <code>currentTarget</code> are set to the highest ancestor's <span class=ref>relative target</span>.
Since it is possible for a script to hold on to the <code>Event</code> object past the scope of event dispatch, this step is necessary to avoid revealing the nodes in <span class=ref>shadow DOM subtrees</span>.
</p>

<h3>Related Target Events</h3>

<p>
Some events have a <code>relatedTarget</code> property, which holds a node that's not the event's target, but is related to the event.
For instance, a <code>mouseover</code> event's <code>relatedTarget</code> may hold the node from which the mouse has moved to event's <code>target</code>.
In the case where <code>relatedTarget</code> is in a <span class=ref>shadow DOM subtree</span>, we don't want to leak its actual value outside of this subtree.
In cases where both <code>relatedTarget</code> and <code>target</code> are part of the same <span class=ref>shadow DOM subtree</span>, we don't want the appearance of spurious <code>mouseover</code> and <code>mouseout</code> events firing from the same node.
</p>

<p>
Thus, if an event has a <code>relatedTarget</code>, its value and extent of event dispatch must to be adjusted. In general:
</p>
<ol>
    <li>If <code>relatedTarget</code> and <code>target</code> are enclosed by a <span class=ref>shadow DOM subtree</span>, the event dispatch must be stopped at the <span class=ref>shadow boundary</span> of this subtree.</li>
    <li>If <code>relatedTarget</code> is separated from <code>target</code> by one or more <span class=ref>shadow boundaries</span>, it must be retargeted to the boundary that's closest to <code>target</code>.</li>
</ol>

<object data="../../assets/images/related-target-and-shadow-dom.svg" width=400 height=400></object>

<p>
The following algorithm must be used:
</p>
<div class="algorithm"><dfn id="relatedtarget-algorithm" title="relatedTarget Algorithm">relatedTarget Algorithm</dfn>
<ol>
    <li>Find the <dfn>lowest common ancestor</dfn> of <code>target</code> and <code>relatedTarget</code>.</li>
    <li>If there is none, skip to step 7 in the algorithm.</li>
    <li>If the <span class=ref>lowest common ancestor</span> is <code>relatedTarget</code>, and it's a <span class=ref>shadow DOM subtree host</span>, make this tree's boundary the <span class=ref>lowest common boundary</span>, and go to step 6 in the algorithm.</li>
    <li>Looking at the ancestors of the <span class=ref>lowest common ancestor</span>, starting at its parent and walking <span class=ref>up</span>, find a <span class=ref>shadow boundary</span>. This is the <dfn>lowest common boundary</dfn>, the boundary of a <span class=ref>shadow DOM subtree</span> that encloses both <code>target</code> and <code>relatedTarget</code>.
    <li>If the <span class=ref>lowest common boundary</span> is not found, skip to step 7 in the algorithm.</li>
    <li>Limit event dispatch to the descendants of the <span class=ref>lowest common boundary</span>.</li>
    <li>If the <span class=ref>lowest common boundary</span> is still undetermined at this point, set it to be the farthest ancestor of the <code>relatedTarget</code>.</li>
    <li>Starting from <span class=ref>lowest common boundary</span> and walking <span class=ref>down</span> ancestors of the <code>relatedTarget</code>, find a <span class=ref>shadow boundary</span>. This is the <dfn>first divergent boundary</dfn>.</li>
    <li>If <span class=ref>first divergent boundary</span> is not found, stop.</li>
    <li>Set <code>relatedTarget</code> to the parent of the <span class=ref>first divergent boundary</span>.
</ol>
</div>

<h3>Focus Events</h3>

<p>
The <code>focus</code>, <code>DOMFocusIn</code>, <code>blur</code>, and <code>DOMFocusOut</code> events must be treated in the same way as events with a <code>relatedTarget</code>,
where the corresponding node that is losing focus as a result of <code>target</code> gaining focus or the node that is gaining focus, and thus causing the blurring of <code>target</code> acts as the related target.
</p>

<h3>Events That Are Always Stopped</h3>

<p>
Mutation events and <code>selectstart</code> event are always stopped at the nearest <span class=ref>shadow boundary</span>.
</p>

<!-- ==================== -->

<h3>Example</h3>

<p>
Suppose we have a user interface for a media controller, built with several components, represented by this <span class=ref>shadow-aware DOM tree</span>:
</p>
<pre class="example html">
&lt;div id=&quot;player&quot;&gt;
    <span class=shadow-boundary>&lt;shadow-boundary&gt;</span>
        &lt;div pseudo=&quot;controls&quot;&gt;
            &lt;button pseudo=&quot;play-button&quot;&gt;
            &lt;input type=&quot;range&quot; pseudo=&quot;timeline&quot;&gt;
                <span class=shadow-boundary>&lt;shadow-boundary&gt;</span>
                    &lt;div pseudo=&quot;slider-thumb&quot;&gt;&lt;/div&gt;
                <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
            &lt;/input&gt;
            &lt;div pseudo=&quot;volume-slider-container&quot;&gt;
                &lt;input type=&quot;range&quot; pseudo=&quot;volume-slider&quot;&gt;
                    <span class=shadow-boundary>&lt;shadow-boundary&gt;</span>
                        &lt;div pseudo=&quot;slider-thumb&quot;&gt;&lt;/div&gt;
                    <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
                &lt;/input&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
&lt;/div&gt;
</pre>

<p>
Let's have a user position their pointing device over the volume slider's thumb (<code>#player::volume-slider::slider-thumb</code>), thus triggering a <code>mouseover</code> event on that node. For this event, let's pretend it has no associated <code>relatedTarget</code>.
</p>

<p>
Just before the event is dispatched, we perform <span class=ref>retargeting</span>:
</p>
<ol>
    <li>We set the <span class=ref>relative target</span> of the thumb node to itself.</li>
    <li>Walking <span class=ref>up</span>, we find a <span class=ref>shadow boundary</span> and skip it.</li>
    <li>Next up is an input (<code>#player::volume-slider</code>), and we set its relative target to itself, since the previous ancestor was a shadow boundary.</li>
    <li>We then walk up to the containing div (<code>#player::volume-slider-container</code>), and use previous ancestor's target -- the input element.</li>
    <li>Walking up one more, we reach the controls panel (<code>#player::controls</code>), and again use input element as relative target per <span class=ref>retargeting</span> algorithm.</li>
    <li>Next, we reach another <span class=ref>shadow boundary</span> and skip it.</li>
    <li>Finally we walk up to the player element (<code>#player</code>) and set its relative target to itself.</li>
</ol>

<pre class="example html">
<span class=event-ancestor>&lt;div id=&quot;player&quot;&gt; <em>7</em></span>
    <span class="shadow-boundary event-ancestor">&lt;shadow-boundary&gt; <em>6</em></span>
        <span class=event-ancestor>&lt;div pseudo=&quot;controls&quot;&gt; <em>5</em></span>
            &lt;button pseudo=&quot;play-button&quot;&gt;
            &lt;input type=&quot;range&quot; pseudo=&quot;timeline&quot;&gt;
                <span class=shadow-boundary>&lt;shadow-boundary&gt;</span>
                    &lt;div pseudo=&quot;slider-thumb&quot;&gt;&lt;/div&gt;
                <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
            &lt;/input&gt;
            <span class=event-ancestor>&lt;div pseudo=&quot;volume-slider-container&quot;&gt; <em>4</em></span>
                <span class=event-ancestor>&lt;input type=&quot;range&quot; pseudo=&quot;volume-slider&quot;&gt; <em>3</em></span>
                    <span class="shadow-boundary event-ancestor">&lt;shadow-boundary&gt; <em>2</em></span>
                        <span class=event-ancestor>&lt;div pseudo=&quot;slider-thumb&quot;&gt;&lt;/div&gt; <em>1</em></span>
                    <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
                &lt;/input&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
&lt;/div&gt;
</pre>

<p>
At the end of this process, we should have the following set of ancestors and relative targets:
</p>
<table>
<thead>
<tr>
    <th>Ancestor</th>
    <th>Relative Target</th>
</tr>
</thead>
<tbody>
<tr>
    <td><code>...</code></td>
    <td><code>div#player</code></td>
</tr>
<tr>
    <td><code>div#player</code></td>
    <td><code><strong>div#player</strong></code></td>
</tr>
<tr>
    <td><code>div#player::controls</code></td>
    <td><code>div#player::controls::volume-slider</code></td>
</tr>
<tr>
    <td><code>div#player::volume-slider-container</code></td>
    <td><code>div#player::controls::volume-slider</code></td>
</tr>
<tr>
    <td><code>div#player::controls::volume-slider</code></td>
    <td><code><strong>div#player::controls::volume-slider</strong></code></td>
</tr>
<tr>
    <td><code>div#player::controls::volume-slider::slider-thumb</code></td>
    <td><code><strong>div#player::controls::volume-slider::slider-thumb</strong></code></td>
</tr>
</tbody>
</table>

<p>
After we dispatch the <code>mouseover</code> event using these newly computed relative targets, the user decides to move their pointing device over the thumb of the timeline
(<code>#player::timeline::slider-thumb</code>). This triggers both a <code>mouseout</code> event for the volume slider thumb and the <code>mouseover</code> event for the timeline thumb.
</p>

<p>
Let's study how the <code>relatedTarget</code> value of the volume thumb's <code>mouseout</code> event is affected and whether event escapes out of the player.
For this event, the <code>relatedTarget</code> is the timeline thumb (<code>#player::timeline::slider-thumb</code>).
</p>

<div class="algorithm">
<ol>
    <li>We find lowest common ancestor of timeline thumb and volume slider thumb: the controls panel (<code>#player::controls</code>).</li>
    <li>Walking <span class=ref>up</span>, we look for a <span class=ref>shadow boundary</span>, and find one just above. This is the lowest common boundary.</li>
    <li>Given that the lowest common boundary exists, we limit event dispatch to the descendants of this boundary.</li>
    <li>Starting from the lowest common boundary, we walk <span class=ref>down</span> the ancestors of the timeline thumb, looking for a <span class=ref>shadow boundary</span>. We find it just below the timeline (<code>#player::timeline</code>). This is the first divergent boundary.</li>
    <li>We adjust <code>relatedTarget</code> to be the parent of the first divergent boundary, the timeline (<code>#player::timeline</code>). We are now ready to dispatch this event.</li>
</ol>
</div>

<pre class="example html">
&lt;div id=&quot;player&quot;&gt;
    <span class="shadow-boundary lowest-common-boundary">&lt;shadow-boundary&gt;<em> &mdash; lowest common boundary</em></span>
        &lt;div pseudo=&quot;controls&quot;&gt;
            &lt;button pseudo=&quot;play-button&quot;&gt;
            &lt;input type=&quot;range&quot; pseudo=&quot;timeline&quot;&gt;
                <span class="shadow-boundary first-divergent-boundary">&lt;shadow-boundary&gt;<em>  &mdash; first divergent boundary</em></span>
                    &lt;div pseudo=&quot;slider-thumb&quot;&gt;&lt;/div&gt;
                <span class="shadow-boundary first-divergent-boundary">&lt;/shadow-boundary&gt;</span>
            &lt;/input&gt;
            &lt;div pseudo=&quot;volume-slider-container&quot;&gt;
                &lt;input type=&quot;range&quot; pseudo=&quot;volume-slider&quot;&gt;
                    <span class=shadow-boundary>&lt;shadow-boundary&gt;</span>
                        &lt;div pseudo=&quot;slider-thumb&quot;&gt;&lt;/div&gt;
                    <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
                &lt;/input&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    <span class="shadow-boundary lowest-common-boundary">&lt;/shadow-boundary&gt;</span>
&lt;/div&gt;
</pre>

<h2>CSS in the Component Model</h2>

<h3>Inheritance Across Boundaries</h3>

<h4>Host-to-Shadow</h4>

<p>Nodes in the shadow tree inherit styles from the host element as if they were direct children.

<h4>Shadow-to-Host-Children</h4>

<p>
Children of the host element that are rendered through a <code>content</code> element
inherit their style as if they were direct children of the <code>content</code> element.
</p>

<h3>Selectors</h3>

<p>CSS Selectors <strong>never</strong> cross the boundary from host to the shadow tree, nor from <code>content</code> elements back to the host or its children.

<p>CSS Rules declared outside the shadow tree do <strong>not</strong> apply to nodes inside it. Conversely, style rules declared inside the shadow tree also do <strong>not</strong> apply to nodes outside.

<p>All of the above also applies to selectors used in certain JavaScript APIs,
such as the <code><a href="http://dev.w3.org/2006/webapi/selectors-api/#nodeselector">querySelector()</a></code> and <code><a href="http://dev.w3.org/2006/webapi/selectors-api/#nodeselector">querySelectorAll()</a></code> functions.

<h2>Rendering of the Component Model</h2>

<h3>Host element</h3>
<p>The <span>host element</span> is rendered as normal, including all applicable styles for the element.</p>

<h3>Children of the host element</h3>
<p>Any content of the <span>host element</span> MUST NOT be rendered directly. Instead, such content will be rendered as determined by <code>content</code> elements inside the shadow tree associated with the <span>host element</span>.

<p>In place of rendering the content of the <span>host element</span>, the shadow tree rooted in the <code>ShadowRoot</code> node associated with the <span>host element</span> is rendered.

<h3>The ShadowRoot node</h3>
<p>The <code>ShadowRoot</code> node itself MUST NOT be rendered.

<h3>Descendants of the ShadowRoot node</h3>
<p>Descendants of the <code>ShadowRoot</code> node are rendered as normal, with the exception of <code>content</code> elements.
<p>Also, styles and style rules declared for the DOM tree the <span>host element</span> resides in are by default <strong>not</strong> applicable to nodes in the shadow tree.

<h3>content elements</h3>
<p><code>content</code> elements are <strong>not</strong> rendered. In their place, the child nodes of the <span>host element</span> selected by the <code>content</code> element are rendered. In case no child node of the <span>host element</span> is selected by the <code>content</code> element, the fallback content of the <code>content</code> element (if any) is rendered instead.

<h3>Example</h3>

<p>
For example, to replicate the <code><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#the-details-element">details</a></code> element, the following shadow tree might be used:
</p>

<pre class="html">
#ShadowRoot
    &lt;div style="display: inline-block;"&gt;
        &lt;div id="summary-line"&gt;
            &lt;span id="expansion-triangle"&gt;▶&lt;/span&gt;&amp;nbsp;&lt;content select="summary:first-of-type"/&gt;
        &lt;/div&gt;
        &lt;div id="explanation" style="display: none;"&gt;
            &lt;content/&gt;
        &lt;/div&gt;
    &lt;/div&gt;
</pre>

The following HTML:

<pre class="html">
&lt;details&gt;
    Initial text
    &lt;summary&gt;Frobnoz&lt;/summary&gt;
    &lt;div style="background-color: mauve"&gt;
        Foo!
    &lt;/div&gt;
    &lt;summary&gt;Mxyzptlk&lt;/summary&gt;
    Exitus
&lt;/details&gt;
</pre>

would result in the following equivalent tree for rendering:

<pre class="html">
&lt;details&gt;
    <span style="color: #604">&lt;div style="display: inline-block;"&gt;</span>
        <span style="color: #604">&lt;div id="summary-line"&gt;</span>
            <span style="color: #604">&lt;span id="expansion-triangle"&gt;▶&lt;/span&gt;&amp;nbsp;&lt;summary&gt;Frobnoz&lt;/summary&gt;</span>
        <span style="color: #604">&lt;/div&gt;</span>
        <span style="color: #604">&lt;div id="explanation" style="display: none;"&gt;</span>
            Initial text
            &lt;div style="background-color: mauve"&gt;
                Foo!
            &lt;/div&gt;
            &lt;summary&gt;Mxyzptlk&lt;/summary&gt;
            Exitus
        <span style="color: #604">&lt;/div&gt;</span>
    <span style="color: #604">&lt;/div&gt;</span>
&lt;/details&gt;
</pre>

<h2>The content Element</h2>

<h3>Overview</h3>

<p>For some use cases it may be useful if the host element is allowed to have children of its own, that then become part of the rendered component. Those children could either be regular HTML content (e.g., for a laying out a component), or components of their own that work hand-in-hand with their parent. To this end, the shadow DOM may contain one or more content elements that define where those children are to be rendered.</p>

<h3>Definition</h3>

<p>The <code>content</code></dfn> element</p>

<pre class="idl">
interface HTMLContentELement : HTMLElement {
    attribute DOMString     <a href="#content.select">select</a>;
}
</pre>


<p>
<code><dfn id="content.select" title="select">select</dfn></code> defines which children of the host element are to be displayed in position of the <code>content</code> element.
It contains a space-separated list of <span>simple selector sequences</span>. Every such sequence may contain:

<ul>
    <li><a href="http://www.w3.org/TR/css3-selectors/#type-selectors">type selector</a> or <a href="http://www.w3.org/TR/css3-selectors/#universal-selector">universal selector</a></li>
    <li><a href="http://www.w3.org/TR/css3-selectors/#class-html">class selector(s)</a></li>
    <li><a href="http://www.w3.org/TR/css3-selectors/#id-selectors">ID selector(s)</a></li>
    <li><a href="http://www.w3.org/TR/css3-selectors/#attribute-selectors">attribute selector(s)</a></li>
    <li><a href="http://www.w3.org/TR/css3-selectors/#pseudo-classes">pseudo-class selector(s)</a>, with certain exceptions (see below)</li>
</ul>

<p>
It MUST NOT contain pseudo-element selectors. If present such a <span>selector sequence</span> is disregarded in its entirety.
</p>

<p>
The following pseudo-classes require special treatment:
</p>
<dl>
    <dt>:link
    <dd>This pseudo-class MUST NOT be honored if the component is <em>confined</em>, in order to avoid leaking browsing history. If present, the whole selector sequence is disregarded in its entirety.
    <dt>:visited
    <dd>This pseudo-class MUST NOT be honored if the component is <em>confined</em>, in order to avoid leaking browsing history. If present, the whole selector sequence is disregarded in its entirety.
    <dt>:hover
    <dd>The user agent MAY honor this pseudo-class, but moving an element that is hovered may likely cause it end up no longer being hovered, likely making this not a useful functionality.
        If the component is <em>confined</em>, this pseudo-class MUST NOT be honored, and selector sequences containing it are disregarded.
    <dt>:active
    <dd>The user agent MAY honor this pseudo-class, moving an element that is being activated is likely not a useful functionality.
        If the component is <em>confined</em>, this pseudo-class MUST NOT be honored, and selector sequences containing it are disregarded.
    <dt>:focus
    <dd>This pseudo-class MUST NOT be honored if the component is <em>confined</em>, and selector sequences containing it are disregarded.
    <dt>:target
    <dd>This pseudo-class MUST NOT be honored if the component is <em>confined</em>, and selector sequences containing it are disregarded.
</dl>

<p>
A <code>content</code> element without a <code><a href="#content.select">select</a></code> attribute selects all children
that are not selected by any other <code><a href="#content">content</a></code> element.
A given shadow tree MUST contain only at most a single <code><a href="#content">content</a></code> element without a <code>select</code> attribute.
In case there are more than one such <code><a href="#content">content</a></code> elements, only the first such content element selects any children.
</p>

<p>
A <code><a href="#content">content</a></code> element may have content of its own,
which is rendered in the case the <code><a href="#content">content</a></code> element doesn't select any children of the host element.
</p>


<h2>Related specs</h2>

<p><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/">HTML5</a></p>

<h2 id="typographic-conventions">Typographic conventions</h2>

<p>(This section, as well as styling and conventions were adopted from the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/">WHATWG HTML5</a> spec and the <a href="http://www.w3.org/">W3C</a> sites.)

<p>This is a definition, requirement, or explanation.</p>

<p class="note">This is a note.</p>

<p class="warning">This is a warning.</p>

<div class="example">This is an example.</div>

<pre class="example">This is a code example.</pre>

<p class="question">This is an unanswered open question.</p>

<p class="issue">This is an issue or problem.</p>

<pre class="idl">
// this is an IDL definition
interface <dfn title="">Example</dfn> {
    ...
};
</pre>

<pre class="html">
&lt;!-- this is a HTML fragment --&gt;
&lt;template tag="x-supercalifragilisticexpialidocious"&gt;
    ...
&lt;/template&gt;
</pre>

<pre class="css">
/* this is a CSS fragment */
.example { ... }
</pre>

<div class="algorithm"><dfn id="catbath" title="Bathing a Cat">Algorithm for Bathing a Cat</dfn>
<ol>
    <li>Don medieval armor. Plate armor is best.
    <li>Grab the kitty. Depending on its reaction:
        <dl>
            <dt>Does it have a particularly grumpy day?
            <dd>Consider calling the ambulance in advance.

            <dt>Otherwise:
            <dd>The risk is manageable.
        </dl>
    <li>Enter the bathroom...
</ol>
</div>

<p>
The defining instance of a term is marked up like <dfn id="x-this" title="x-this">this</dfn>. Uses of that term are marked up like <a href="#x-this">this</a>.
</p>

<p>
The defining instance of an element, attribute, or API is marked up like <dfn id="x-that" title="x-that"><code>this</code></dfn>.
References to that element, attribute, or API are marked up like <code><a href="#x-that">this</a></code>.
</p>

<p>
Other code fragments are marked up <code>like this</code>.
</p>

<p>
Variables are marked up like <var>this</var>.
</p>

</body>
</html>
