<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'/>
    <title>Shadow DOM</title>
    <script src='./autolink-config.js' class='remove'></script>
    <script src='../../assets/scripts/autolink.js' class='remove'></script>
    <link rel="stylesheet" href="../../assets/styles/respec-complement.css" type="text/css" />
    <script src='//www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus: "ED",
          shortName: "shadow-dom",
          editors: [{ name: "Dimitri Glazkov", url: "mailto:dglazkov@chromium.org", company: "Google, Inc." },
                    { name: "Hayato Ito", url: "mailto:hayato@google.com", company: "Google, Inc." }],
          wg: "W3C Web Applications (WebApps)",
          wgURI: "http://www.w3.org/2008/webapps/",
          wgPublicList: "public-webapps",
          wgPatentURI: "",
          edDraftURI: "http://w3c.github.io/webcomponents/spec/shadow/",
          otherLinks: [
              {
                  key: "Revision history",
                  href: "https://github.com/w3c/webcomponents/commits/gh-pages/spec/shadow/"
              }
          ],
          localBiblio: {
              "SELECTORS4": {
                  title: "Selectors Level 4",
                  href: "http://dev.w3.org/csswg/selectors4/",
                  authors: ["Elika Etemad", "Tab Atkins Jr"],
                  status: "ED"
              },
              "DOMPARSING": {
                  title: "DOM Parsing and Serialization",
                  href: "http://domparsing.spec.whatwg.org/",
                  authors:  ["Ms2ger"]
              },
              "EDITING": {
                  title: "HTML Editing APIs",
                  href: "https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html",
                  authors:  ["Aryeh Gregor"]
              }
          }
      };
      var bugAssistConfig = {
          blocked: '14978',
          short_desc: '[Shadow]: ',
          product: 'WebAppsWG',
          component: 'Component Model'
      };
    </script>
    <script src="../../assets/scripts/bug-assist.js" class="remove"></script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This specification describes a method of establishing and maintaining functional boundaries between DOM trees
        and how these trees interact with each other within a document, thus enabling better functional encapsulation
        within the DOM.
      </p>
    </section>

    <section id='sotd'>
    </section>

    <section>
      <h2>Conformance</h2>

      <p>All diagrams, examples, notes, are non-normative, as well as sections explicitly marked as non-normative. Everything else in this specification is normative.</p>

      <p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this document are to be interpreted as described in [[!RFC2119]]. For readability, these words do not appear in all uppercase letters in this specification.</p>

      <p>To help with layering and to avoid circular dependencies between various parts of specification, this document consists of three consecutive narratives:</p>
      <ol>
        <li>setting up the stage for the specification,</li>
        <li>explaining of the conceptual model and algorithms behind it, and</li>
        <li>expressing this model with DOM interfaces and HTML elements.</li>
      </ol>

      <p>In a sense, these parts can be viewed as <em>math</em>, which sets up the reasoning environment, <em>physics</em>, which is the theoretical reasoning about the concept, and <em>mechanics</em>, which is the practical application of this reasoning.</p>

      <p>Any point, at which a conforming UA must make decisions about the state or reaction to the state of the conceptual model, is captured as <a href="http://en.wikipedia.org/wiki/Algorithm">algorithm</a>. The algorithms are defined in terms of processing equivalence. The <dfn>processing equivalence</dfn> is a constraint imposed on the algorithm implementors, requiring the output of the both UA-implemented and the specified algorithm to be exactly the same for all inputs.</p>
    </section>

    <section id="concepts">
      <h2>Concepts</h2>

      <p class="issue">In order to solve the problem of mysterious definitions, we may have to make a concise, complete introduction here. It should explain what shadowing means, how it relates rendering, and what problem shadow DOM solves.</p>

      <section>
        <h3>Shadow trees</h3>

        <p>A <dfn>document tree</dfn> is a <a>node tree</a> [[!DOM]] whose <a>root</a> <a>node</a> is a <a>document</a>.</p>

        <p>Any element can have an <dfn title="shadow roots list">associated ordered list</dfn> of zero or more <a title="node tree">node trees</a>.</p>

        <p>An element <dfn>hosts</dfn> a <a>node tree</a> if the <a>node tree</a> is a member of this associated list.</p>

        <p>A <dfn>shadow host</dfn> is an element that <a>hosts</a> one or more <a title="node tree">node trees</a>.</p>

        <p>A <dfn>shadow tree</dfn> is a <a>node tree</a> <a title="hosts">hosted</a> by a <a>shadow host</a>.</p>

        <p>A <dfn>shadow root</dfn> is the <a>root</a> <a>node</a> of a shadow tree.</p>

        <p>If more than one <a>shadow root</a> is <a title="hosts">hosted</a> by the same <a>shadow host</a>, the more recently added <a>shadow root</a> is called the <dfn>younger shadow root</dfn>, and the less recently added <a>shadow root</a> is called the <dfn>older shadow root</dfn>.</p>

        <p>If there is no <a>older shadow root</a> than a given <a>shadow root</a>,
          the <a>shadow root</a> is called the <dfn>oldest shadow root</dfn>.</p>

        <p>If there is no <a>younger shadow root</a> than a given <a>shadow root</a>,
          the <a>shadow root</a> is called the <dfn>youngest shadow root</dfn>.</p>
      </section>

      <section>
        <h3>Trees of trees</h3>

        <p>A <dfn>tree of trees</dfn> is a <a>tree</a> of <a title="node tree">node trees</a>.</p>

        <figure>
          <object data="../../assets/images/tree-of-trees.svg" width="650" height="823"></object>
          <figcaption>A tree of trees</figcaption>
        </figure>

        <p>Just like a <a>node tree</a> is defined as <a title="tree">a set of relationships</a> between <a title="node">nodes</a>,
          a <a>tree of trees</a> is similarly defined as a set of relationships between <a title="node tree">node trees</a>:</p>
        <ul>
          <li>A <a>node tree</a> <var>A</var> is called a <dfn>parent tree</dfn> of a <a>node tree</a> <var>B</var> if the <a>shadow host</a> of <var>B</var> <a>participates</a> in <var>A</var>.</li>
          <li>If there is more than one <a>node tree</a> that shares the same <a>parent tree</a>, the <a>tree order</a> between them in the <a>tree of trees</a> is defined as follows:
            <ol>
              <li>Let <var>A</var> and <var>B</var> be <a title="node tree">node trees</a> that share the same <a>parent tree</a>.</li>
              <li><var>A</var> comes before <var>B</var> if either of the following conditions is satisfied:
                <ul>
                  <li>Both <var>A</var> and <var>B</var> are <a title="hosts">hosted</a> by the same <a>shadow host</a> and <var>A</var> is <a title="older shadow root">older</a> than <var>B</var>.</li>
                  <li>The <a>shadow host</a> which <a>hosts</a> <var>A</var> is <a>preceding</a> the <a>shadow host</a> which <a>hosts</a> <var>B</var>.</li>
                </ul>
              </li>
            </ol>
          </li>
          <li>Other relationships and terms, such as <dfn>root tree</dfn>, <dfn>child tree</dfn>,
            <dfn>descendant tree</dfn>, <dfn>inclusive descendant tree</dfn>,
            <dfn>ancestor tree</dfn>, <dfn>inclusive ancestor tree</dfn>,
            <dfn>preceding tree</dfn>
            are defined in the similar way as defined in <a title="tree">trees</a>.</li>
        </ul>

        <p class="note">The <a>document tree</a> is always the <a>root tree</a> of a <a>tree of trees</a>.</p>
      </section>

      <section>
        <h3>Composed trees</h3>

        <p>A <dfn>composed tree</dfn> is a <a>node tree</a> which is constructed out of <a title="node">nodes</a> from multiple <a title="node tree">node trees</a> in a <a>tree of trees</a>.
          The exact algorithm of constructing a composed tree is specified later.</p>

        <figure>
          <object data="../../assets/images/composed-tree.svg" width="654" height="606"></object>
          <figcaption>A composed tree</figcaption>
        </figure>

        <p>In <dfn>rendering</dfn> a <a>document tree</a>, or presenting it visually, the <a>composed tree</a> <strong>must</strong> be used instead of the <a>document tree</a>.</p>

        <p>If any condition which affects a <a>composed tree</a> has changed, the <a>composed tree</a> <strong>must</strong> be updated before the <a>rendering</a> occurs.</p>

        <p class="issue">We should probably enumerate these conditions, here or later.</p>
      </section>

      <section>
        <h3>Distributions</h3>

        <p>An <dfn>insertion point</dfn> is a defined location where <a title="node">nodes</a> in a different <a>node tree</a> appear instead of the nodes's original position when constructing a <a>composed tree</a>.</p>

        <figure>
          <object data="../../assets/images/distributions.svg" width="663" height="598"></object>
          <figcaption>A distribution</figcaption>
        </figure>

        <p>A <dfn>distribution</dfn> is the mechanism that determines which <a title="node">nodes</a> appear at each <a>insertion point</a>. The exact algorithm of a <a>distribution</a> is specified later.</p>
      </section>

    </section>

    <section>
      <h2>Encapsulation</h2>

      <p>The <a><code>ownerDocument</code></a> property of a <a>node</a> in a shadow tree <strong>must</strong> refers to the <a>document</a> of the <a>shadow host</a> which <a>hosts</a> the shadow tree.</p>

      <p><a><code>Window</code></a> object <a title="named access on the window object">named properties</a> [[!HTML]] <strong>must</strong> access the <a title="node">nodes</a> in the <a>root tree</a>.</p>

      <p class="note">For convenience, the <a>shadow root</a> provides its own set of <a title="DOM tree accessors">DOM tree accessor</a> methods. No <a title="node">nodes</a> other than the <a>shadow root</a> descendants are accessible with these methods.</p>

      <p class="issue">This section is tiny. Maybe we could merge it into some other place? Encapsulation is effectively a natural property of having multiple trees.</p>
    </section>

    <section id="distributions">
      <h2>Distributions</h2>

      <section id="content-insertion-points">
        <h3>Content Insertion Points</h3>

        <p>A <dfn>content insertion point</dfn> is an <a>insertion point</a> to where the child <a title="node">nodes</a> of the <a>shadow host</a> are distributed.
          The <a>content element</a> that satisfies all of the following conditions represents a <a>content insertion point</a>:</p>
        <ul>
          <li>The <a>root</a> <a>node</a> of the <a>content element</a> is a <a>shadow root</a></li>
          <li>There is no other <a>content element</a> in the <a title="ancestor">ancestors</a> of the <a>content element</a></li>
          <li>There is no other <a>shadow element</a> in the <a title="ancestor">ancestors</a> of the <a>content element</a></li>
        </ul>

        <p class="issue">Bring in HTML element and interface definitions here</p>
      </section>

      <section id="shadow-insertion-points">
        <h3>Shadow Insertion Points</h3>

        <p>A <dfn>shadow insertion point</dfn> is an <a>insertion point</a> to where the children of the <a>older shadow root</a> are distributed.
          The <a>shadow element</a> that satisfies of the following conditions represents a <a>shadow insertion point</a>:</p>
        <ul>
          <li>The <a>root</a> <a>node</a> of the <a>shadow element</a> is a <a>shadow root</a></li>
          <li>There is no other <a>shadow element</a> which is <a>preceding</a> the <a>shadow element</a></li>
          <li>There is no other <a>content element</a> in the <a title="ancestor">ancestors</a> of the <a>shadow element</a></li>
        </ul>

        <p class="issue">Bring in HTML element and interface definitions here</p>
      </section>

      <section id="distribution-results">
        <h3>Distribution Results</h3>

        <p>Each <a>tree of trees</a> has the <dfn>distribution result</dfn> which describes the result of distributions.
          The <a>distribution result</a> <strong>must</strong> be <a title="processing equivalence">equivalent</a> of the following:</p>
        <ol>
          <li>Each <a>insertion point</a> has an ordered list, called <dfn>distributed nodes</dfn>, which consists of <a title="node">nodes</a> which are distributed into the <a>insertion point</a>.</li>
          <li>Each <a>node</a> that is not an <a>insertion point</a> has an ordered list, called <dfn>destination insertion points</dfn>, which consists of <a title="insertion point">insertion points</a> to where the <a>node</a> is distributed</li>
        </ol>

        <div class="note">
          <p>One case that deserves special consideration is the situation when an <a>insertion point</a> is a child <a>node</a> of another <a>shadow host</a>. In such situations, the <a title="node">nodes</a> <a title="distributes">distributed</a> into that <a>insertion point</a> appear as if they were child <a title="node">nodes</a> of the <a>shadow host</a> in the context of <a>distribution</a>. Thus, the <a title="node">nodes</a> <a title="distributes">distributed</a> to a <a>shadow tree</a> could have already been <a title="distributes">distributed</a> from its parent tree.</p>

          <p>Despite being distributed to more than one insertion point, a node still only appears once in the composed tree at the final destination.</p>
        </div>

        <figure>
          <object data="../../assets/images/re-distributions.svg" width="693" height="822"></object>
          <figcaption>A re-distribution.
            In the figure, a node <em>child 1</em> is distributed into <em>insertion point 1</em>. Then <em>child1</em> is re-distributed into <em>insertion point 3</em>.
            The destination insertion points of <em>child 1</em> is [<em>insertion point 1</em>, <em>insertion point 3</em>] and <em>insertion point 3</em> is the final destination of <em>child 1</em>.
            The distributed nodes of <em>insertion point 1</em> and <em>insertion point 3</em> is [<em>child 1</em>] and [<em>child 1</em>, <em>child 3</em>], respectively.
          </figcaption>
        </figure>

        <p>When a <a>node</a> <var>A</var> is <dfn title="distributes">distributed</dfn> into an <a>insertion point</a> <var>B</var>, the following steps <strong>must</strong> happen:</p>
        <ul>
          <li>Add <var>A</var> to the <a>distributed nodes</a> of <var>B</var></li>
          <li>Add <var>B</var> to the <a>destination insertion points</a> of <var>A</var></li>
        </ul>

        <p>An <a>insertion point</a> <var>A</var> is the <dfn>final destination</dfn> of a <a>node</a> <var>B</var> if <var>A</var> is the last item of the <a>destination insertion points</a> of <var>B</var>.</p>
      </section>

      <section id="distribution-algorithms">
        <h3>Distribution Algorithms</h3>

        <p>The <dfn>distribution algorithm</dfn> <strong>must</strong> be used to determine the <a>distribution result</a> for a <a>tree of trees</a> and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>TREE-OF-TREES</var>, a <a>tree of trees</a></dd>
            <dt>Output</dt>
            <dd>The <a>distribution result</a> of <var>TREE-OF-TREES</var> is updated</dd>
          </dl>
          <ol>
            <li>Let all <a>distributed nodes</a> and <a>destination insertion points</a> owned by <a title="node">nodes</a> in <var>TREE-OF-TREES</var> be empty</li>
            <li>Let <var>ROOT</var> be the <a>root</a> <a>node</a> of the <a>root tree</a> of <var>TREE-OF-TREES</var></li>
            <li>Run the <a>distribution resolution algorithm</a> with <var>ROOT</var> as input</li>
          </ol>
        </div>

        <p>The <dfn>distribution resolution algorithm</dfn> <strong>must</strong> be used to determine the <a>distribution result</a> for a given <a>node tree</a> and its <a title="descendant tree">descendant trees</a>, and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>ROOT</var>, the <a>root</a> <a>node</a> of a <a>node tree</a></dd>
            <dt>Output</dt>
            <dd>The <a>distribution result</a> is updated for the <a title="inclusive descendant tree">inclusive descendant trees</a> of <var>ROOT</var></dd>
          </dl>

          <ol>
            <li>For each <a>shadow host</a>, <var>SHADOW-HOST</var>, that is a <a>descendant</a> of <var>ROOT</var>, in <a>tree order</a>:
              <ol>
                <li>Let <var>POOL</var> be the result of the <a>pool population algorithm</a> with <var>SHADOW-HOST</var> as input</li>
                <li>For each <a>shadow root</a>, <var>SHADOW-ROOT</var>, which <var>SHADOW-HOST</var> <a>hosts</a>, in order from the <a>youngest shadow root</a> to the <a>oldest shadow root</a>:
                  <ol>
                    <li>Run the <a>pool distribution algorithm</a> with <var>SHADOW-ROOT</var> and <var>POOL</var> as input</li>
                  </ol></li>
                <li>For each <a>shadow root</a>, <var>SHADOW-ROOT</var>, that <var>SHADOW-HOST</var> <a>hosts</a>, in order from the <a>oldest shadow root</a> to the <a>youngest shadow root</a>:
                  <ol>
                    <li>Let <var>SHADOW</var> be the <a>shadow insertion point</a> which is a <a>descendant</a> of <var>SHADOW-ROOT</var></li>
                    <li>If such a <var>SHADOW</var> exits:
                      <ol>
                        <li>If <var>SHADOW-ROOT</var> is not the <a>oldest shadow root</a>:
                          <ol>
                            <li>Let <var>POOL</var> be the result of the <a>pool population algorithm</a> with the <a>older shadow root</a> relative to <var>SHADOW-ROOT</var> as input.</li>
                          </ol></li>
                        <li>For each <a>node</a>, <var>CHILD</var>, in <var>POOL</var>
                          <ol>
                            <li><a title="distributes">Distribute</a> <var>CHILD</var> into <var>SHADOW</var></li>
                          </ol></li>
                      </ol></li>
                    <li>Run the <a>distribution resolution algorithm</a>, recursively, with <var>SHADOW-ROOT</var> as input</li>
                  </ol></li>
              </ol></li>
          </ol>
        </div>

        <p>The <dfn>pool population algorithm</dfn> <strong>must</strong> be used to populate <a title="node">nodes</a> from the child <a title="node">nodes</a> of a given <a>node</a> and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>NODE</var>, a node</dd>
            <dt>Output</dt>
            <dd><var>POOL</var>, an ordered list of nodes</dd>
          </dl>

          <ol>
            <li>Let <var>POOL</var> be an empty ordered list.</li>
            <li>For each child <a>node</a>, <var>CHILD</var>, of <var>NODE</var>:
              <ol>
                <li>If <var>CHILD</var> is an <a>insertion point</a>:
                  <ol>
                    <li>Add all <a title="node">nodes</a> in the <a>distributed nodes</a> of <var>CHILD</var> to <var>POOL</var></li>
                  </ol></li>
                <li>Otherwise:
                  <ol>
                    <li>Add <var>CHILD</var> to <var>POOL</var></li>
                  </ol></li>
              </ol></li>
          </ol>
        </div>

        <p>The <dfn>pool distribution algorithm</dfn> <strong>must</strong> be used to distribute <a title="node">nodes</a> in a pool into the <a title="content insertion point">content insertion points</a> in a <a>shadow tree</a> and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>SHADOW-ROOT</var>, a shadow root</dd>
            <dd><var>POOL</var>, an ordered list of nodes</dd>
            <dt>Output</dt>
            <dd>Nodes in POOL are distributed into the content insertion points in the tree.</dd>
          </dl>

          <ol>
            <li>For each <a>content insertion point</a>, <var>CONTENT</var>, which is descendant of <var>SHADOW-ROOT</var>, in tree order:
              <ol>
                <li>For each <a>node</a>, <var>NODE</var>, in <var>POOL</var>
                  <ol>
                    <li>If <var>NODE</var> satisfies <var>CONTENT</var>'s matching criteria:
                      <ol>
                        <li><a title="distributes">Distribute</a> <var>NODE</var> into <var>CONTENT</var></li>
                        <li>Remove <var>NODE</var> from <var>POOL</var></li>
                      </ol></li>
                  </ol></li>
                <li>If there is no <a title="node">nodes</a> distributed to <var>CONTENT</var>:
                  <ol>
                    <li>For each child, <var>CHILD</var>, of <var>CONTENT</var>
                      <ol>
                        <li><a title="distributes">Distribute</a> <var>CHILD</var> into <var>CONTENT</var></li>
                      </ol></li>
                  </ol></li>
              </ol></li>
          </ol>

        </div>

        <p class="note">When there is no nodes distributed into a <a>content insertion point</a> <var>CONTENT</var>, the child <a title="node">nodes</a> of <var>CONTENT</var> are distributed into <var>CONTENT</var> as fallback nodes.</p>
      </section>

      <section id="satisfying-matching-criteria">
        <h3>Satisfying Matching Criteria</h3>

        <p>The <dfn>matching criteria</dfn> for an <a>insertion point</a> is a set of <a title="compound selector">compound selectors</a> [[!SELECTORS4]]. These <a title="compound selector">compound selectors</a> are restricted to contain only these <a title="simple selector">simple selectors</a>:</p>

        <ul>
          <li>A <a>type selector</a> or a <a>universal selector</a></li>
          <li><a title="class selector">class selector(s)</a></li>
          <li>An <a>ID selector</a></li>
          <li><a title="attribute selector">attribute selector(s)</a></li>
        </ul>

        <p>A <a>node</a> <dfn title="satisfies-matching-criteria">satisfies</dfn> a <a>matching criteria</a> only if:</p>
        <ol>
          <li>all <a title="compound selector">compound selectors</a> in the set, contain only the <a title="simple selector">simple selectors</a> specified above; and</li>
          <li>a <a>node</a> matches at least one <a title="compound selector">compound selectors</a> in the set or the set is empty.</li>
        </ol>
      </section>

      <section>
        <h3><code>::content</code> pseudo-element</h3>

        <p>The <dfn title="content pseudo-element">::content</dfn> is a pseudo-element that represents a relationship between a <a>content insertion point</a> in a <a>shadow tree</a> and an <a>element</a> whose <a>inclusive ancestor</a> is <a title="distributes">distributed</a> into that <a>content insertion point</a>. The <a>relative selector</a> following <a title="content pseudo-element"><code>::content</code></a> pseudo-element is <a title="scope contained selectors">scope-contained</a>, with the <a>reference element set</a> initialized to the <a>parent</a> of the <a href="">element</a>, distributed to the <a>content insertion point</a>.</p>

        <div class="note">
          <p>For example, the following selector represents the all <code>div</code> elements that are descendants of an element, distributed into a <a>content insertion point</a></p>
          <pre class="highlight">
    ::content div
          </pre>
          <p>This selector represents all child <code>span</code> elements that are distributed into <a title="content insertion point">content insertion points</a> with class attribute <code>victory</code></p>
          <pre class="highlight">
    .victory::content > span
          </pre>
        </div>

        <p class="issue">Should reference element set be insertion point or parent?</p>
      </section>

    </section>

    <section id="composition">
      <h2>Composition</h2>

      <p>The <dfn>composed tree children calculation algorithm</dfn> <strong>must</strong> be used to determine the child <a title="node">nodes</a> of a <a>node</a> in the <a>composed tree</a> and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

      <div class="algorithm">
        <dl>
          <dt>Input</dt>
          <dd><var>NODE</var>, a <a>node</a> which participates in a composed tree</dd>
          <dt>Output</dt>
          <dd><var>CHILDREN</var>, the child nodes of <var>NODE</var> in the <a>composed tree</a>.</dd>
        </dl>

        <ol>
          <li>Let <var>CHILDREN</var> be an empty ordered list of nodes</li>
          <li>If <var>NODE</var> is a <a>shadow host</a>:
            <ol>
              <li>Let <var>CHILD-POOL</var> be the children of the <a>youngest shadow root</a> which <var>NODE</var> <a>hosts</a>.</li>
            </ol></li>
          <li>Otherwise:
            <ol>
              <li>Let <var>CHILD-POOL</var> be the child <a title="node">nodes</a> of NODE</li>
            </ol></li>
          <li>For each <a>node</a>, <var>CHILD</var>, in <var>CHILD-POOL</var>:
            <ol>
              <li>If <var>CHILD</var> is an <a>insertion point</a>:
                <ol>
                  <li>For each <a>node</a>, <var>DISTRIBUTED-NODE</var>, in the <a>distributed nodes</a> of the <a>insertion point</a> <var>CHILD</var>:
                    <ol>
                      <li>If <var>CHILD</var> is the <a>final destination</a> of <var>DISTRIBUTED-NODE</var>, add <var>DISTRIBUTED-NODE</var> to <var>CHILDREN</var></li>
                    </ol></li>
                </ol></li>
              <li>Otherwise:
                <ol>
                  <li>Add <var>CHILD</var> to <var>CHILDREN</var></li>
                </ol></li>
            </ol></li>
        </ol>

      </div>

      <p>For a given <a>tree of trees</a> <var>TREE-OF-TREES</var>, the <a>composed tree</a> constructed from <var>TREE-OF-TREES</var> <strong>must</strong> be <a title="processing equivalence">equivalent</a> to the following tree:</p>
      <ul>
        <li>The <a>root</a> <a>node</a> of the <a>composed tree</a> is the <a>root</a> <a>node</a> of the <a>root tree</a> of <var>TREE-OF-TREES</var>.</li>
        <li>For a given <a>node</a> which <a>participates</a> in the <a>composed tree</a>, the child <a title="node">nodes</a> of the <a>node</a> is the result of the <a>composed tree children calculation algorithm</a> with the <a>node</a> as input.
        </li>
      </ul>
    </section>

    <section id="events">
      <h2>Events</h2>

      <p>When an <a>event</a> is <a title="event dispatch">dispatched</a> in a <a>shadow tree</a>, its path either crosses the <a title="shadow tree">shadow trees</a> or is terminated at the <a>shadow root</a>. One exception are the <a title="mutation event">mutation events</a>. The <a title="mutation event">mutation event types</a> <strong>must</strong> never be dispatched in a <a>shadow tree</a>.</p>

      <section id="events-that-are-always-stopped">
        <h3>Events that are Always Stopped</h3>

        <p>The <dfn title="events-always-stopped">following events</dfn> <strong>must</strong> always be stopped at the <a>root</a> <a>node</a> of the <a>node tree</a>:</p>
        <ul>
          <li><code>abort</code></li>
          <li><code>error</code></li>
          <li><code>select</code></li>
          <li><code>change</code></li>
          <li><code>load</code></li>
          <li><code>reset</code></li>
          <li><code>resize</code></li>
          <li><code>scroll</code></li>
          <li><code>selectstart</code></li>
        </ul>
      </section>

      <section id="event-paths">
        <h3>Event Paths</h3>

        <p>The <dfn>event path calculation algorithm</dfn> must be used to determine event path and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>NODE</var>, a node</dd>
            <dd><var>EVENT</var>, an event</dd>
            <dt>Output</dt>
            <dd><var>PATH</var>, an event path, a ordered list of an event target</dd>
          </dl>
          <ol>
            <li>Let <var>PATH</var> be the empty ordered list of nodes</li>
            <li>Let <var>CURRENT</var> be <var>NODE</var></li>
            <li>Add <var>CURRENT</var> to <var>PATH</var></li>
            <li><dfn id="event-path-calculation-algorithm-repeat">Repeat</dfn> while <var>CURRENT</var> exists:
              <ol>
                <li>If the <a>destination insertion points</a> of <var>CURRENT</var> is not empty:
                  <ol>
                    <li>For each <a>insertion point</a>, <var>INSERTION-POINT</var>, in the <a>destination insertion points</a> of <var>CURRENT</var>:
                      <ol>
                        <li>If <var>INSERTION-POINT</var> is a <a>shadow insertion point</a>:
                          <ol>
                            <li>Let <var>SHADOW-ROOT</var> be the <a>root</a> <a>node</a> of <var>INSERTION-POINT</var></li>
                            <li>If <var>SHADOW-ROOT</var> is not the <a>oldest shadow root</a>:
                              <ol>
                                <li>Add the <a>older shadow root</a> relative to <var>SHADOW-ROOT</var> to <var>PATH</var></li>
                              </ol></li>
                          </ol></li>
                        <li>Add <var>INSERTION-POINT</var> to <var>PATH</var></li>
                      </ol></li>
                    <li>Let <var>CURRENT</var> be the <a>final destination</a> of <var>CURRENT</var></li>
                  </ol></li>
                <li>Otherwise:
                  <ol>
                    <li>If <var>CURRENT</var> is a <a>shadow root</a>:
                      <ol>
                        <li>If <var>NODE</var> and <var>CURRENT</var> are in the same <a>node tree</a> and <var>EVENT</var> is one of the <a title="events-always-stopped">events which must be stopped</a>:
                          <ol>
                            <li>Stop this algorithm</li>
                          </ol></li>
                        <li>Let <var>CURRENT</var> be the <a>shadow host</a> which <a>hosts</a> <var>CURRENT</var></li>
                        <li>Add <var>CURRENT</var> to <var>PATH</var></li>
                      </ol></li>
                    <li>Otherwise:
                      <ol>
                        <li>Let <var>CURRENT</var> be the <a>parent</a> <a>node</a> of <var>CURRENT</var></li>
                        <li>If <var>CURRENT</var> exists:
                          <ol>
                            <li>Add <var>CURRENT</var> to <var>PATH</var></li>
                          </ol></li>
                      </ol></li>
                  </ol></li>
              </ol></li>
          </ol>
        </div>

        <p class="note">For convenience, an event path may include shadow roots or <a title="insertion point">insertion points</a> so that event listeners registered on the shadow roots or the <a title="insertion point">insertion points</a> would be invoked.</p>
      </section>

      <section id="event-retargeting">
        <h3>Event Retargeting</h3>

        <p>In the cases where event path is across multiple node trees, the event's information about the target of the event is adjusted in order to maintain <a href="#encapsulation">encapsulation</a>. Event <dfn>retargeting</dfn> is a process of computing relative targets for each ancestor of the <a>node</a> at which the event is dispatched. A <dfn>relative target</dfn> is a <a>node</a> that most accurately represents the target of a dispatched event at a given ancestor while maintaining the <a href="#encapsulation">encapsulation</a>.</p>

        <p>The <dfn>retargeting algorithm</dfn> is used to determine relative targets, and it <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>PATH</var>, an event path</dd>
            <dd><var>CURRENT-TARGET</var>, a <a>node</a> where the event listener is invoked.</dd>
            <dt>Output</dt>
            <dd><var>RELATIVE-TARGET</var>, adjusted target</dd>
          </dl>
          <ol>
            <li>Let <var>CURRENT-TARGET-TREE</var> be the <a>node tree</a> which <var>CURRENT-TARGET</var> <a>participates</a> in</li>
            <li>Let <var>ORIGINAL-TARGET</var> be the first item in <var>PATH</var></li>
            <li>Let <var>ORIGINAL-TARGET-TREE</var> be the <a>node tree</a> which <var>ORIGINAL-TARGET</var> <a>participates</a> in</li>
            <li>Let <var>RELATIVE-TARGET-TREE</var> be the lowest common <a>inclusive ancestor</a> tree of <var>CURRENT-TARGET-TREE</var> and <var>ORIGINAL-TARGET-TREE</var></li>
            <li>Let <var>RELATIVE-TARGET</var> be the <a>node</a> which satisfies all the following conditions:
              <ol>
                <li>The <a>node</a> <a>participates</a> in <var>RELATIVE-TARGET-TREE</var></li>
                <li>The <a>node</a> is a member of <var>PATH</var></li>
                <li>There is no other descendant <a>node</a> which satisfies the conditions.</li>
              </ol></li>
          </ol>
        </div>

        <p>The retargeting process <strong>must</strong> occur prior to dispatch of an event.</p>
      </section>

      <section id="retargeting-related-target">
        <h3>Retargeting <code>relatedTarget</code></h3>

        <p>Some events have a <a><code>relatedTarget</code></a> [[!DOM-Level-3-Events]] property, which holds a <a>node</a> that's not the event's target, but is related to the event.</p>

        <p>For instance, a <code>mouseover</code> event's <a><code>relatedTarget</code></a> may hold the <a>node</a> from which the mouse has moved to event's <code>target</code>. In the case where <code>relatedTarget</code> is in a <a>shadow tree</a>, the conforming UAs <strong>must</strong> not leak its actual value outside of this tree. In cases where both <code>relatedTarget</code> and <code>target</code> are part of the same <a>shadow tree</a>, the conforming UAs <strong>must</strong> <em>stop</em> events at the shadow root to avoid the appearance of spurious <code>mouseover</code> and <code>mouseout</code> events firing from the same node.</p>

        <p>Thus, if an event has a <code>relatedTarget</code>, its value and extent of event dispatch <strong>must</strong> be adjusted. In general:</p>
        <ol>
          <li>For a given node, the <code>relatedTarget</code> <strong>must</strong> be changed to its ancestor (or self) that is in the same <a>shadow tree</a> as the node</li>
          <li>Event listeners <strong>must not</strong> be invoked on a <a>node</a> for which the <code>target</code> and <code>relatedTarget</code> are the same.</li>
        </ol>

        <p>The <dfn>related target resolution algorithm</dfn> <strong>must</strong> be used to determine the value of the <a><code>relatedTarget</code></a> property and <strong>must</strong> be <a title="processing equivalence">equivalent</a> to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>CURRENT-TARGET</var>, the <a>node</a> on which event listeners would be invoked</dd>
            <dd><var>RELATED-TARGET</var>, the related target for the event</dd>
            <dt>Output</dt>
            <dd><var>ADJUSTED-RELATED-TARGET</var>, the <dfn>adjusted related target</dfn> for <var>NODE</var></dd>
          </dl>
          <ol>
            <li>Let <var>ADJUSTED-RELATED-TARGET</var> be null</li>
            <li>Let <var>RELATED-TARGET-PATH</var> be the result of the event path calculation algorithm with <var>RELATED-TARGET</var> as input</li>
            <li>For each <a>inclusive ancestor</a> tree, <var>CURRENT-TREE</var>, of the <a>node tree</a> which <var>CURRENT-TARGET</var> <a>participates</a> in, in ascending order:
              <ol>
                <li>For each <a>node</a>, <var>RELATED-TARGET-PATH-ANCESTOR</var>, in the <var>RELATED-TARGET-PATH</var>:
                  <ol>
                    <li>If <var>RELATED-TARGET-PATH-ANCESTOR</var> <a>participates</a> in <var>CURRENT-TREE</var>:
                      <ol>
                        <li>Let <var>ADJUSTED-RELATED-TARGET</var> be RELATED-TARGET-PATH-ANCESTOR</li>
                        <li>Stops</li>
                      </ol></li>
                  </ol></li>
              </ol></li>
          </ol>
        </div>

        <p class="note">The result of the related target resolution algorithm is not always null. Unless that, you should file a bug for this specification.</p>
      </section>

      <section id="retargeting-touch-events">
        <h3>Retargeting Touch Events</h3>

        <p>The <a><code>Touch</code></a> <a title="Touch target"><code>target</code></a> [[!TOUCH-EVENTS]] attribute must be adjusted in the same way as an event with a <a><code>relatedTarget</code></a>. Each <a><code>Touch</code></a> <a title="Touch target"><code>target</code></a> in the <a><code>TouchList</code></a> returned from <a><code>TouchEvent</code></a> <a title="touches"><code>touches()</code></a>, <a title="changedTouches"><code>changedTouches()</code></a> and <a title="targetTouches"><code>targetTouches()</code></a> must be the result of <a>related target resolution algorithm</a>, given <var>NODE</var> and <a><code>Touch</code></a> <a title="Touch target"><code>target</code></a> as arguments.</p>
      </section>

      <section id="retargeting-focus-events">
        <h3>Retargeting Focus Events</h3>

        <p>The <code>focus</code>, <code>DOMFocusIn</code>, <code>blur</code>, and <code>DOMFocusOut</code> events <strong>must</strong> be treated in the same way as events with a <code>relatedTarget</code>, where the corresponding <a>node</a> that is losing focus as a result of <code>target</code> gaining focus or the <a>node</a> that is gaining focus, and thus causing the blurring of <code>target</code> acts as the related target.</p>
      </section>

      <section id="event-dispatch">
        <h3>Event Dispatch</h3>

        <p>At the time of event dispatch:</p>
        <ul>
          <li>The <a><code>Event</code></a> <a><code>target</code></a> and <a><code>currentTarget</code></a> attributes <strong>must</strong> return the <a>relative target</a> for the <a>node</a> on which event listeners are <a title="event listener invoke">invoked</a></li>
          <li>The <a><code>MouseEvent</code></a> <a><code>relatedTarget</code></a> attribute <strong>must</strong> return the <a>adjusted related target</a></li>
          <li>The <a><code>MouseEvent</code></a> <a><code>offsetX</code></a> and <a><code>offsetY</code></a> attributes <strong>must</strong> return the coordinates relative to the origin of the <a>padding edge</a> of the <a>relative target</a></li>
          <li>The <a><code>Touch</code></a> <a title="Touch target"><code>target</code></a> attribute <strong>must</strong> return the <a>adjusted related target</a></li>
          <li>If the <a><code>relatedTarget</code></a> and <a><code>target</code></a> are the same for a given node, its the event listeners <strong>must not</strong> be invoked. <a><code>TouchEvent</code></a> is not subject to this rule.</li>
          <li>When <em>capturing</em>, which entails processing step 6 of the <a title="event dispatch">event dispatch algorithm</a>, the event listeners <strong>must not</strong> be <a title="event listener invoke">invoked</a> on a <a>node</a> <strong>if</strong> it is the same as its <a>relative target</a></li>
          <li>When <em>bubbling</em>, which entails processing step 9 of the <a title="event dispatch">event dispatch algorithm</a>, the <a><code>Event</code></a> <a>eventPhase</a> attribute <strong>must</strong> return <a>AT_TARGET</a> <strong>if</strong> the <a>relative target</a> is same as the <a>node</a> on which event listeners are <a title="event listener invoke">invoked</a></li>
          <li>If the event's <a><code>bubbles</code></a> attribute value is <strong>false</strong>, run these substeps:
            <ol>
              <li>Reverse the order of <em>event path</em></li>
              <li>Initialize event's <a><code>eventPhase</code></a> attribute to <a><code>AT_TARGET</code></a></li>
              <li>For each object in <em>event path</em> where the <a>relative target</a> is same as the object, <a title="event listener invoke">invoke</a> its <a title="event listener">event listeners</a>, with event <em>event</em>, as long as <em>event</em>'s <a>stop propagation flag</a> is unset</li>
            </ol></li>
        </ul>

        <p>Upon completion of the event dispatch, the <a><code>Event</code></a> object's <a><code>target</code></a> and <a><code>currentTarget</code></a> <strong>must</strong> be to the highest ancestor's <a>relative target</a>. Since it is possible for a script to hold on to the <code>Event</code> object past the scope of event dispatch, this step is necessary to avoid revealing the <a title="node">nodes</a> in <a title="shadow tree">shadow trees</a>.</p>
      </section>

      <section id="event-retargeting-example">
        <h3>Event Retargeting Example</h3>

        <p class="issue">This example should be rewritten based on the current retargeting algorithm</p>

        <p>Suppose we have a user interface for a media controller, represented by this tree, composed of both <a>document tree</a> and the <a title="shadow tree">shadow trees</a>. In this example, we will assume that selectors are allowed to cross the shadow boundaries and we will use these selectors to identify the <a title="element">elements</a>. Also, we will invent a fictional <code>shadow-root</code> <a>element</a> to demarcate the shadow boundaries> and represent <a title="shadow root">shadow roots</a>:</p>
        <pre class="example">
&lt;div id=&quot;player&quot;&gt;
    <span class=shadow-boundary>&lt;shadow-root id=&quot;player-shadow-root&quot;&gt;</span>
        &lt;div id=&quot;controls&quot;&gt;
            &lt;button class=&quot;play-button&quot;&gt;PLAY&lt;/button&gt;
            &lt;input type=&quot;range&quot; id=&quot;timeline&quot;&gt;
                <span class=shadow-boundary>&lt;shadow-root id=&quot;timeline-shadow-root&quot;&gt;</span>
                    &lt;div class=&quot;slider-thumb&quot; id=&quot;timeline-slider-thumb&quot;&gt;&lt;/div&gt;
                <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
            &lt;/input&gt;
            &lt;div class=&quot;volume-slider-container&quot;&gt;
                &lt;input type=&quot;range&quot; class=&quot;volume-slider&quot;&gt;
                    <span class=shadow-boundary>&lt;shadow-root id=&quot;volume-shadow-root&quot;&gt;</span>
                        &lt;div class=&quot;slider-thumb&quot; id=&quot;volume-slider-thumb&quot;&gt;&lt;/div&gt;
                    <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
                &lt;/input&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    <span class=shadow-boundary>&lt;/shadow-root&gt;</span>
&lt;/div&gt;
        </pre>

        <p>Let's have a user position their pointing device over the volume slider's thumb (<code>#volume-slider-thumb</code>), thus triggering a <code>mouseover</code> event on that node. For this event, let's pretend it has no associated <code>relatedTarget</code>.</p>

        <p>Just before the event is dispatched, we perform <a>retargeting</a>:</p>
        <ol>
          <li>Since <code>#volume-slider-thumb</code> is not an <a>insertion point</a>, we push it onto <var>STACK</var>, and add the first tuple to <var>TARGETS</var> as (<code>#volume-slider-thumb</code>, <code>#volume-slider-thumb</code>)</li>
          <li>We then calculate parent as <code>#volume-shadow-root</code> and proceed to second iteration, adding (<code>#volume-slider-thumb</code>, <code>#volume-shadow-root</code>) tuple to <var>TARGETS</var></li>
          <li>Because <code>#volume-shadow-root</code> is a <a>shadow root</a>, we pop <var>STACK</var>, thus emptying it</li>
          <li>Next parent calculation yields <code>#volume-slider</code>, and so we begin the third iteration</li>
          <li>Here, <var>STACK</var> is empty again, so we push <code>#volume-slider</code> into it and add (<code>#volume-slider</code>, <code>#volume-slider</code>) to <var>TARGETS</var></li>
          <li>The parent of <code>#volume-slider</code> is <code>#volume-slider-container</code> not a <a>shadow root</a> and not an <a>insertion point</a>, which dictates that we add (<code>#volume-slider</code>, <code>#volume-slider-container</code>) to <var>TARGETS</var></li>
          <li>Next up, we see <code>#controls</code>, again neither a <a>shadow root</a> nor an <a>insertion point</a>, which means we add (<code>##volume-slider</code>, <code>#controls</code>) to <var>TARGETS</var></li>
          <li>The next ancestor is <code>#player-shadow-root</code>, a <a>shadow root</a>, and thus we add it (<code>#volume-slider</code>, <code>#player-shadow-root</code>) to <var>TARGETS</var>, then pop <var>STACK</var>, emptying it</li>
          <li>Its parent is <code>#player</code>, neither <a>shadow root</a> nor <a>insertion point</a>, and <var>STACK</var> is empty, so we push <code>#player</code> to <var>STACK</var>, then add (<code>#player</code>, <code>#player</code>) to <var>TARGETS</var></li>
          <li>In our example, there are no further parents, causing us to exit the loop and stop.</li>
        </ol>

        <p>At the end of this process, we should have the following set of ancestors and relative targets:</p>
        <table>
          <thead>
            <tr>
              <th>Ancestor</th>
              <th>Relative Target</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>#player</code></td>
              <td><code><strong>#player</strong></code></td>
            </tr>
            <tr>
              <td><code>#player-shadow-root</code></td>
              <td><code>#volume-slider</code></td>
            </tr>
            <tr>
              <td><code>#controls</code></td>
              <td><code>#volume-slider</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-container</code></td>
              <td><code>#volume-slider</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider</code></td>
              <td><code><strong>#volume-slider</strong></code></td>
            </tr>
            <tr>
              <td><code>#volume-shadow-root</code></td>
              <td><code>#volume-slider-thumb</code></td>
            </tr>
            <tr>
              <td><code>#volume-slider-thumb</code></td>
              <td><code><strong>#volume-slider-thumb</strong></code></td>
            </tr>
          </tbody>
        </table>

        <p>After we dispatch the <code>mouseover</code> event using these newly computed relative targets, the user decides to move their pointing device over the thumb of the timeline
          (<code>#timeline-slider-thumb</code>). This triggers both a <code>mouseout</code> event for the volume slider thumb and the <code>mouseover</code> event for the timeline thumb.</p>

        <p>Let's study how the <code>relatedTarget</code> value of the volume thumb's <code>mouseout</code> event is affected. For this event, the <code>relatedTarget</code> is the timeline thumb (<code>#timeline-slider-thumb</code>). Per algorithm:</p>

        <ol>
          <li>Starting with <var>NODE</var> as <code>#volume-slider-thumb</code> and <var>RELATED</var> as <code>#timeline-slider-thumb</code>,</li>
          <li>We examine ancestors of <var>RELATED</var>:
            <ol>
              <li>First up> is <code>#timeline-slider-thumb</code>, and we push it into <var>STACK</var></li>
              <li>Then it's <code>#timeline-shadow-root</code>, a <a>shadow root</a>, so we pop <var>STACK</var>, emptying it</li>
              <li>Next is <code>#timeline</code>, we push it into <var>STACK</var></li>
              <li>Then comes <code>#controls</code> and after it, <code>#player-shadow-root</code>, a <a>shadow root</a>, so we pop <var>STACK</var>, emptying it</li>
              <li>Final ancestor is <code>#player</code>, we push it into <var>STACK</var></li>
            </ol></li>
          <li>Set <var>TARGET</var> to <code>#volume-shadow-root</code></li>
          <li>We again examine ancestors of <var>RELATED</var> and notice that it produces the same result as our previous such examination</li>
          <li>We then set <var>TARGET</var> to <code>#volume-slider</code> and</li>
          <li>Repeat examination of ancestors once more&mdash;and realize that when <var>ANCESTOR</var> value is <code>#timeline</code>, the <var>ANCESTOR</var> and <var>TARGET</var> are in the same tree, and thus</li>
          <li>Return <code>#timeline</code> as the adjusted <code>relatedTarget</code> value.</li>
        </ol>

        <p>Performing this computation with <var>NODE</var> as <code>#player</code> yields the result of both <code>target</code> and <code>relatedTarget</code> being the same value (<code>#player</code>), which means that we do not dispatch the event on this <a>node</a> and its ancestors.</p>
      </section>

    </section>

    <section id="styles">
      <h2>Styles</h2>

      <p class="issue">This section is outdated. This section should be rewritten so that it uses the concept of a <a>tree of trees</a> to define the cascading order among node trees more clealy.</p>

      <p class="issue">Hats, <code>^</code>, and Cats, <code>^^</code>, selector combinators should be defined in this section.</p>

      <p>Each <a>shadow root</a> has an associated list of zero or more <a title="style sheet">style sheets</a> [[!CSSOM]], named <dfn>shadow root style sheets</dfn>. This is an ordered list that contains all <a title="style sheet">style sheets</a>, associated with the <a>shadow root</a>, in <a>tree order</a>.</p>

      <p>When a <a>shadow host</a> has multiple <a title="shadow root">shadow roots</a>, the <a>cascade order</a> [[!CSS3CASCADE]] of <a>CSS rules</a> [[!CSS2]], defined in <a>shadow root style sheets</a>, in ascending order of precedence <strong>must</strong> match the order of the <a title="shadow roots list">associated orderred list</a>, ending with the <a>youngest shadow root</a>.</p>

      <p><a>CSS rules</a> declared in a <a>node tree</a> <strong>must not</strong> apply in other <a title="node tree">node trees</a> with a exception:</p>

      <ol>
        <li>Rules that contain a <a title="content pseudo-element"><code>::content</code> pseudo-element</a> match <a title="element">elements</a> in the <a title="ancestor tree">ancestor trees</a>;</li>
      </ol>

      <p>In a <a>document</a> that contains <a title="shadow tree">shadow trees</a>, the CSS properties <strong>must</strong> be inherited from parent nodes, produced using the <a>event path calculation algorithm</a>. This requirement has the following effects:</p>
      <ul>
        <li>the styles of the <a>shadow host</a> are inherited by the children of the <a>shadow root</a></li>
        <li>the styles of the <a>content insertion point</a> <a title="node">nodes</a> are inherited by those child <a title="node">nodes</a> of the <a>shadow host</a> that are <a title="distributes">distributed</a> to this <a>content insertion point</a></li>
        <li>the styles of the <a>shadow insertion point</a> <a>node</a> are inherited by the child <a title="node">nodes</a> of the <a>shadow root</a> of the <a>shadow tree</a>, <a title="distributes">distributed</a> to this <a>shadow insertion point</a></li>
      </ul>

      <p>If the <dfn>reset-style-inheritance</dfn> flag is set for a <a>shadow tree</a>, all <a title="inheritance">inheritable</a> CSS properties <strong>must</strong> behave as if they were explicitly set to the <a title="initial values">initial value</a> at the <a>shadow root</a>.</p>

      <p>If the <a>reset-style-inheritance</a> flag is set for an <a>insertion point</a> in a <a>shadow tree</a>, all <a title="inheritance">inheritable</a> CSS properties <strong>must</strong> behave as if they were explicitly set to the <a title="initial values">initial value</a> at the <a>insertion point</a>.</p>

      <section id="css-variables">
        <h3>CSS Variables</h3>

        <p>The <a>shadow host</a> styles being inherited by the children of the <a>shadow root</a> <strong>must</strong> also apply to <a>CSS Variables</a> [[!css-variables]]. This provides a way for <a>document tree</a> styles to send signals into the <a title="shadow tree">shadow trees</a>, and for the <a title="shadow tree">shadow trees</a> to receive these signals with the use of the <a><code>var()</code></a> function.</p>
      </section>

      <section id="text-decoration-property">
        <h3><code>text-decoration</code> Property</h3>

        <p>The text decorations, specified by the <a><code>text-decoration</code></a> property <strong>must not</strong> be propagated from <a title="shadow host">shadow hosts</a> to <a title="shadow tree">shadow trees</a>.</p>
      </section>

    </section>

    <section id="user-interaction">
      <h2>User Interaction</h2>

      <section id="ranges-and-selection">
        <h3>Ranges and Selections</h3>

        <p>Since <a title="node">nodes</a> which are in the different <a title="node tree">node trees</a> never have the same <a>root</a>, there may never exist a valid <a title="range">DOM range</a> that spans multiple <a title="node tree">node trees</a>.</p>

        <p>Accordingly, <a title="selection">selections</a> [[!EDITING]] may only exist within one <a>node tree</a>, because they are defined by a single <a>range</a>. The <a>selection</a>, returned by the <a><code>window.getSelection()</code></a> method <strong>must</strong> never return a <a>selection</a> within a <a>shadow tree</a>.</p>

        <p>The <code>getSelection()</code> method of the <a>shadow root</a> object <strong>must</strong> return the current <a>selection</a> in this <a>shadow tree</a>.</p>
      </section>

      <section id="focus-navigation">
        <h3>Focus Navigation</h3>

        <p>If a <a>node</a> doesn’t <a title="participates">participate</a> in the <a>composed tree</a>, the <a>node</a> <strong>must</strong> be skipped from the <a>navigation order</a> [[!CSS3UI]] sequence.</p>

        <p>The <a>navigation order</a> within a <a>shadow tree</a> <strong>must</strong> be computed as a list of <a>focusable</a> <a title="element">elements</a> in <a>tree order</a>, and is called <dfn>shadow tree navigation order</dfn>.</p>

        <p>For <a>sequential focus navigation</a>, the <a>shadow tree navigation order</a> sequence for a given <a>shadow tree</a> <var>A</var> <strong>must</strong> be inserted into other <a>navigation order</a> as follow:</p>
        <ol>
          <li>If the <a>root</a> <a>node</a> of <var>A</var> is the <a>youngest shadow root</a>:
            <ol>
              <li>Let <var>B</var> be the <a>parent tree</a> of <var>A</var></li>
              <li>Let <var>HOST</var> be the <a>shadow host</a> which <a>hosts</a> A</li>
              <li>The <a>shadow tree navigation order</a> for A <strong>must</strong> be inserted into the <a>navigation order</a> for <var>B</var>:
                <ol>
                  <li>immediately after <var>HOST</var>, if <var>HOST</var> is <a>focusable</a>; or</li>
                  <li>in place of the <var>HOST</var> as if <var>HOST</var> were assigned the value of <a title="nav-index auto"><code>auto</code></a> for determining its position.</li>
                </ol></li>
            </ol></li>
          <li>Otherwise:
            <ol>
              <li>Let <var>B</var> be the <a>younger shadow root</a> relative to <var>A</var></li>
              <li>Let <var>SHADOW</var> be the <a>shadow insertion point</a> in <var>B</var></li>
              <li>If <var>SHADOW</var> exists, the <a>shadow tree navigation order</a> for <var>A</var> <strong>must</strong> be inserted into the <a>navigation order</a> for <var>B</var> immediately after <var>SHADOW</var> as if <var>SHADOW</var> were assigned the value of <a title="nav-index auto"><code>auto</code></a> for determining its position.</li>
            </ol></li>
        </ol>

        <p>For <a>directional focus navigation</a>, it is up to the user agent to integrate the <a title="shadow tree navigation order">shadow tree navigation orders</a> into the <a>document</a> <a>navigation order</a>.</p>
      </section>

      <section id="active-element">
        <h3>Active Element</h3>

        <p>To maintain encapsulation, the value of the <a title="Document object">Document</a> object's focus API property <a>activeElement</a> <strong>must</strong> be adjusted. To prevent loss of information when adjusting this value, each <a>shadow root</a> <strong>must</strong> also have an <code>activeElement</code> property to store the value of the focused <a>element</a> in the <a>shadow tree</a>.</p>

        <p>The <dfn id="active-element-adjustment-algorithm">active <a>element</a> adjustment algorithm</dfn> is used to determine the value of the <a>activeElement</a> property, and it <strong>must</strong> be equivalent to processing the following steps:</p>

        <div class="algorithm">
          <dl>
            <dt>Input</dt>
            <dd><var>ELEMENT</var>, the focused <a>element</a></dd>
            <dd><var>ROOT</var>, either a <a>document</a> or a <a>shadow root</a></dd>
            <dt>Output</dt>
            <dd><var>ADJUSTED</var>, an adjusted <a>activeElement</a> property of <var>ROOT</var>.</dd>
          </dl>
          <ol>
            <li>Let <var>PATH</var> be the result of the <a>event path calculation algorithm</a> with <var>ELEMENT</var> and null as input</li>
            <li>Let <var>ADJUSTED</var> be the result of the <a>retargeting algorithm</a> with <var>PATH</var> and <var>ROOT</var> as input</li>
          </ol>
        </div>
      </section>

      <section id="editing">
        <h3>Editing</h3>

        <p>The value of the <a><code>contenteditable</code></a> attribute <strong>must not</strong> propagate from <a>shadow host</a> to its <a title="shadow tree">shadow trees</a>.</p>
      </section>

      <section id="assistive-technology">
        <h3>Assistive Technology</h3>

        <p>User agents with assistive technology traverse the <a>composed tree</a>, and thus enable full use of WAI-ARIA [[!WAI-ARIA]] semantics in the <a title="shadow tree">shadow trees</a>.</p>

      </section>

    </section>

    <section id="html-elements">
      <h2>HTML Elements in Shadow Trees</h2>

      <p>Comparatively, a <a>shadow tree</a> can be seen as somewhere between <em>just part of a <a>document</a></em> and itself being a <a title="interface DocumentFragment">document fragment</a>. Since it is rendered, a <a>shadow tree</a> aims to retain the traits of a typical <a>tree</a> in a <a>document</a>. At the same time, it is an encapsulation abstraction, so it has to avoid affecting the <a>document tree</a>. Thus, the <a>HTML elements</a> <strong>must</strong> behave as specified [[!HTML] in the <a title="shadow tree">shadow trees</a>, with a few exceptions.</p>

      <section id="inert-html-elements">
        <h3>Inert HTML Elements</h3>

        <p>A subset of <a>HTML elements</a> <strong>must</strong> behave as <dfn>inert</dfn>, or not part of the <a>document tree</a>. This is consistent how the <a>HTML elements</a> would behave in a <a title="interface DocumentFragment">document fragment</a>. These <a title="element">elements</a> are:</p>
        <ul>
          <li><a title="base element"><code>base</code></a></li>
          <li><a title="link element"><code>link</code></a></li>
        </ul>

        <p>All other <a>HTML elements</a> in the <a title="shadow tree">shadow trees</a> <strong>must</strong> behave as if they were part of the <a>document tree</a>.</p>
      </section>

      <section id="html-forms">
        <h3>HTML Forms</h3>

        <p>The <a>forms</a> in HTML are scoped at the <a>document</a> level. That is, all <a title="form element"><code>form</code></a> <a title="element">elements</a> and <a title="form-associated element">form-associated elements</a> are accessible using the <a>document</a> <a title="interface Document">DOM object</a>'s <a>tree accessors</a>. This <strong>must</strong> exclude <a title="element">elements</a> in the <a title="shadow tree">shadow trees</a>.</p>

        <p>Instead, each <a>shadow tree</a> <strong>must</strong> scope its <a title="form element"><code>form</code></a> <a title="element">elements</a> and <a title="form-associated element">form-associated elements</a>. Because the <a title="form element"><code>form</code></a>'s <a><code>ownerDocument</code></a> is the <a>shadow host</a>'s <a>document</a>, the form submission <strong>must</strong> continue to work <a title="form submission">as specified</a>.</p>
      </section>

    </section>

    <section id="html-elements-and-their-shadow-trees">
      <h2>HTML Elements and Their Shadow Trees</h2>

      <p>Per <a title="HTML">specification</a>, some <a>HTML elements</a> are designed to either not render their contents or have special requirements in regard to contents rendering. In order to reconcile these differences in rendering behavior with the <a>composed tree</a>, all <a>HTML elements</a> <strong>must</strong> have an <a title="processing equivalence">equivalent</a> of a <a>shadow tree</a> that is created and populated at the time of <a>element</a> instantiation. It is up to a user agent to define the content of these trees. However, all conforming user agents <strong>must</strong> satisfy the following requirements:</p>

      <table>
        <thead>
          <tr>
            <th style="width: 30%">HTML Element</th>
            <th>Shadow Tree Requirements</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><a title="img element"><code>img</code></a>, <a title="iframe element"><code>iframe</code></a>, <a title="embed element"><code>embed</code></a>, <a title="object element"><code>object</code></a>, <a title="video element"><code>video</code></a>, <a title="audio element"><code>audio</code></a>, <a title="canvas element"><code>canvas</code></a>, <a title="map element"><code>map</code></a>, <a title="input element"><code>input</code></a>, <a title="textarea element"><code>textarea</code></a>, <a title="progress element"><code>progress</code></a>, <a title="meter element"><code>meter</code></a></td>
            <td>If the <a>element</a> can have <a>fallback content</a>, contains one <a>content insertion point</a>. The <a>matching criteria</a> value is the <a>universal selector</a> only when the <a>element</a> needs to show <a>fallback content</a>. Otherwise, contains no <a title="content insertion point">content insertion points</a> or an <a>content insertion point</a> that matches nothing.</td>
          </tr>
          <tr>
            <td><a title="fieldset element"><code>fieldset</code></a></td>
            <td>Contains two <a title="content insertion point">content insertion points</a> with the following <a>matching criteria</a>:
              <ol>
                <li><code>legend:first-of-type</code></li>
                <li><a>universal selector</a></li>
              </ol>
            </td>
          </tr>
          <tr>
            <td><a title="details element"><code>details</code></a></td>
            <td>Contains two <a title="content insertion point">content insertion points</a> with the following <a>matching criteria</a>:
              <ol>
                <li><code>summary:first-of-type</code></li>
                <li><a>universal selector</a></li>
              </ol>
            </td>
          </tr>
          <tr>
            <td>All other <a title="element">elements</a></td>
            <td>Contains one <a>content insertion point</a> with the <a>universal selector</a> as the <a>matching criteria</a></td>
          </tr>
        </tbody>
      </table>
    </section>

    <section id="elements-and-dom-objects">
      <h2>Elements and DOM Objects</h2>

      <section>
        <h3><code>ShadowRoot</code> Object</h3>

        <p>The <code>ShadowRoot</code> object represents the <a>shadow root</a>.</p>

        <dl class="idl" title="interface ShadowRoot : DocumentFragment">
          <dt>HTMLElement getElementById(DOMString elementId)</dt>
          <dd>
            <strong>Must</strong> behave exactly like <a>document.getElementById</a>, except <a title="scoping constraints">scoped</a> to the <a>shadow tree</a>.
          </dd>

          <dt>NodeList getElementsByClassName(DOMString className)</dt>
          <dd>
            <strong>Must</strong> behave exactly like <a>document.getElementsByClassName</a>, except <a title="scoping constraints">scoped</a> to the <a>shadow tree</a>.
          </dd>

          <dt>NodeList getElementsByTagName(DOMString tagName)</dt>
          <dd>
            <strong>Must</strong> behave exactly like <a>document.getElementsByTagName</a>, except <a title="scoping constraints">scoped</a> to the <a>shadow tree</a>.
          </dd>

          <dt>NodeList getElementsByTagNameNS(DOMString? namespace, DOMString localName)</dt>
          <dd>
            <strong>Must</strong> behave exactly like <a>document.getElementsByTagNameNS</a>, except <a title="scoping constraints">scoped</a> to the <a>shadow tree</a>.
          </dd>

          <dt>Selection? getSelection()</dt>
          <dd>
            <p>Returns the current selection in the <a>shadow tree</a>.</p>
            <p>When invoked, it <strong>must</strong> return the <a>selection</a> in the <a>shadow tree</a>.</p>
          </dd>

          <dt>Element? elementFromPoint(float x, float y)</dt>
          <dd>
            <p>Returns an <a>element</a> at specified coordinates.</p>
            <p class="note">Eventually, this needs to be part of CSSOM View Module specification [[!CSSOM-VIEW]]</p>
            <p>
              When invoked, it <strong>must</strong> return result of running the following steps:
            </p>
            <ol>
              <li>If <a>context object</a> is not a <a><code>ShadowRoot</code></a> instance, throw an <a><code>InvalidNodeTypeError</code></a>.</li>
              <li>If either argument is negative, <code>x</code> is greater than the <a>viewport</a> width excluding the size of a rendered scroll bar (if any), or if <code>y</code> is greater than the <a>viewport</a> height excluding the size of a rendered scroll bar (if any), return <strong>null</strong>.</li>
              <li>Let <var>HIT</var> be the <a>element</a> at coordinates <code>x</code> and <code>y</code> in the <a>viewport</a>, determined through hit testing</li>
              <li>Let <var>PATH</var> be the result of running the <a>event path calculation algorithm</a> with <var>HIT</var> as input</li>
              <li>Return the result of running the <a>retargeting algorithm</a> with <var>PATH</var> and <a>context object</a> as input</li>
            </ol>
          </dd>

          <dt>attribute bool resetStyleInheritance</dt>
          <dd>
            <p>Represents the <a>reset-style-inheritance</a> flag and indicates whether or not the inheritable CSS properties are set to the initial value at the shadow boundary. If <code>false</code> (default value), the properties continue to inherit. If <code>true</code>, the properties are set to initial value.</p>
            <p>On getting, the attribute <strong>must</strong> return the current value of the <a>reset-style-inheritance</a> flag for the <a>shadow host</a>'s tree.</p>
            <p>On setting, the attribute <strong>must</strong> set the value of the <a>reset-style-inheritance</a> flag for the <a>shadow host</a>'s <a>tree</a> to specified value.</p>
          </dd>

          <dt>readonly attribute Element? activeElement</dt>
          <dd>
            <p>Represents the currently focused <a>element</a> in the <a>shadow tree</a>.</p>
            <p>On getting, the attribute <strong>must</strong> return the currently focused <a>element</a> in the <a>shadow tree</a> or <code>null</code>, if there is none.</p>
          </dd>

          <dt>readonly attribute Element host</dt>
          <dd>
            <p>Represents the <a>shadow host</a> which <a>hosts</a> the <a>context object</a>.</p>
            <p>On getting, the attribute <strong>must</strong> return the <a>shadow host</a> which <a>hosts</a> the <a>context object</a>.</p>
          </dd>

          <dt>readonly attribute ShadowRoot? olderShadowRoot</dt>
          <dd>
            <p>Represents the <a>older shadow root</a> relative to the <a>context object</a></p>
            <p>
              On getting, the attribute <strong>must</strong> return a result that is <a title="processing equivalence">equivalent</a> to running the following steps:
            </p>
            <ol>
              <li>If the <a>context object</a> is the <a>oldest shadow root</a>, return <strong>null</strong>.</li>
              <li>Return the <a>older shadow root</a> relative to the <a>context object</a>.</li>
            </ol>
            <p>For <a>HTML elements</a>, the <a href="#html-elements-and-their-shadow-trees">UA-provided</a> <a title="shadow tree">shadow trees</a> <strong>must not</strong> be accessible.</p>
          </dd>

          <dt>attribute DOMString innerHTML</dt>
          <dd>
            <p>Represents the markup of <a><code>ShadowRoot</code></a>'s contents.</p>
            <p>On getting, the attribute <strong>must</strong> return the result of running the <a>HTML fragment serialization algorithm</a> with the <a>context object</a> as <a title="shadow host"><code>shadow host</code></a>.</p>
            <p>
              On setting, these steps <strong>must</strong> be run:
            </p>
            <ol>
              <li>Let <var>FRAGMENT</var> be the result of invoking the <a title="parse fragment">fragment parsing algorithm</a> [[!DOMPARSING]] with the new value as <var>MARKUP</var>, and the <a>context object</a> as <a title="shadow host"><code>shadow host</code></a></li>
              <li><a>Replace all</a> with <var>FRAGMENT</var> within the <a>shadow root</a>.</li>
            </ol>
          </dd>

          <dt>readonly attribute StyleSheetList styleSheets</dt>
          <dd>
            <p>Represents the <a>shadow root style sheets</a>.</p>
            <p>On getting, the attribute <strong>must</strong> return a <code>StyleSheetList</code> sequence containing the <a>shadow root style sheets</a>.
            </p>
          </dd>
        </dl>

        <p>The <a><code>nodeType</code></a> attribute of a <a><code>ShadowRoot</code></a> instance <strong>must</strong> return <a><code>DOCUMENT_FRAGMENT_NODE</code></a>. Accordingly, the <a><code>nodeName</code></a> attribute of a <a><code>ShadowRoot</code></a> instance <strong>must</strong> return <code>"#document-fragment"</code>.</p>

        <p>Invoking the <a><code>cloneNode()</code></a> method on a <a><code>ShadowRoot</code></a> instance <strong>must</strong> always throw a <a><code>DATA_CLONE_ERR</code></a> exception.</p>

      </section>

      <section id="extensions-to-element">
        <h3>Extensions to <code>Element</code> Interface</h3>

        <dl class="idl" title="partial interface Element">
          <dt>ShadowRoot createShadowRoot()</dt>
          <dd>
            When invoked, these steps <strong>must</strong> be run:
            <ol>
              <li>Create a new instance of the <a><code>ShadowRoot</code></a> object</li>
              <li>Add the <a><code>ShadowRoot</code></a> object to the <a title="shadow roots list">ordered list of shadow roots</a> associated with the <a>context object</a> as the <a>youngest shadow root</a></li>
              <li>Return <a><code>ShadowRoot</code></a> object.</li>
            </ol>
          </dd>

          <dt>NodeList getDestinationInsertionPoints()</dt>
          <dd>When invoked, the method <strong>must</strong> return a <a>static</a> <a><code>NodeList</code></a> consisting of <a title="insertion point">insertion points</a> in the <a>destination insertion points</a> of the <a>context object</a>.</dd>

          <dt>readonly attribute ShadowRoot? shadowRoot</dt>
          <dd>
            <p>Represents the <a>youngest shadow root</a> that <a>context object</a> <a>hosts</a>.</p>
            <p>On getting, the attribute <strong>must</strong> return the <a>youngest shadow root</a> that <a>context object</a> <a>hosts</a>, or <strong>null</strong> if no such <a>shadow root</a> is accessible.</p>
            <p>For <a>HTML elements</a>, the <a href="#html-elements-and-their-shadow-trees">UA-provided</a> <a title="shadow tree">shadow trees</a> <strong>must not</strong> be accessible.</p>
          </dd>
        </dl>
      </section>

      <section id="content-element">
        <h3>The <code>content</code> element</h3>

        <p>The <code><dfn title="content element">content</dfn></code> element represents an <a>insertion point</a> in the <a>shadow tree</a>.</p>

        <p>If a <code>content</code> element does not satisfy the condition of an <a>insertion point</a>, it <strong>must</strong> have the same rendering behavior as the <a><code>HTMLUnknownElement</code></a>.</p>

        <dl>
          <dt>Context</dt>
          <dd>Where <a>flow content</a> is expected.</dd>

          <dt>Content model</dt>
          <dd><a>Transparent</a></dd>

          <dt>Children</dt>
          <dd>Anything as fallback content</dd>

          <dt>Content attributes</dt>
          <dd><a>Global attributes</a></dd>
          <dd>
            <dl>
              <dt id="markup-content-select"><code>select</code>, a <a title="comma separated tokens">set of comma-separated tokens</a></dt>
              <dd>Represents the <a>matching criteria</a> for <a title="distribution">distributing</a> child <a title="node">nodes</a> of the <a>shadow host</a>. Each token <strong>must</strong> be a <a>compound selector</a>.</dd>

              <dt id="markup-content-reset-style-inheritance"><code>resetstyleinheritance</code>, a <a>boolean</a> attribute</dt>
              <dd>Indicates the state of the <a>reset-style-inheritance</a> flag for this <a>insertion point</a>. If present, the value of the flag <strong>must</strong> be set to <strong>true</strong>. Otherwise, the value <strong>must</strong> be set to <strong>false</strong>.</dd>
            </dl>
          </dd>

          <dt>DOM Interface</dt>
          <dd>
            <dl class="idl" title="interface HTMLContentElement : HTMLElement">
              <dt>attribute DOMString select</dt>
              <dd><strong>Must</strong> <a>reflect</a> the <a href="#markup-content-select">select</a> attribute.</dd>

              <dt>attribute boolean resetStyleInheritance</dt>
              <dd><strong>Must</strong> <a>reflect</a> the <a href="#markup-content-reset-style-inheritance">resetstyleinheritance</a> attribute.</dd>

              <dt>NodeList getDistributedNodes()</dt>
              <dd>
                When invoked, it <strong>must</strong> return result of running the following steps:
                <ol>
                  <li>
                    If the <a>context object</a> is a <a>content insertion point</a>:
                    <ol>
                      <li>Return a <a>static</a> <a><code>NodeList</code></a> consisting of nodes in the <a>distributed nodes</a> of the <a>context object</a>.</li>
                    </ol>
                  </li>
                  <li>
                    Otherwise:
                    <ol>
                      <li>Return an empty <a>static</a> <a><code>NodeList</code></a>.</li>
                    </ol>
                  </li>
                </ol>
              </dd>
            </dl>
          </dd>
        </dl>
      </section>

      <section id="shadow-element">
        <h3>The <code>shadow</code> element</h3>

        <p>The <code><dfn title="shadow element">shadow</dfn></code> element represents an <a>shadow insertion point</a> in a <a>shadow tree</a>.</p>
        <p>If a <code>shadow</code> element does not satisfy the condition of an <a>insertion point</a>, it <strong>must</strong> have the same rendering behavior as the <a><code>HTMLUnknownElement</code></a>.</p>

        <dl>
          <dt>Context</dt>
          <dd>Where <a>flow content</a> is expected.</dd>

          <dt>Content model</dt>
          <dd><a>Transparent</a></dd>

          <dt>Children</dt>
          <dd>Anything as fallback content</dd>

          <dt>Content attributes</dt>
          <dd>
            <p><a>Global attributes</a></p>
            <dl>
              <dt id="markup-shadow-reset-style-inheritance"><code>resetstyleinheritance</code>, a <a>boolean</a> attribute</dt>
              <dd>indicates the state of the <a>reset-style-inheritance</a> flag for this <a>shadow insertion point</a>. If present, the value of the flag <strong>must</strong> be set to <strong>true</strong>. Otherwise, the value <strong>must</strong> be set to <strong>false</strong>.</dd>
            </dl>
          </dd>

          <dt>DOM Interface</dt>
          <dd>
            <dl class="idl" title="interface HTMLShadowElement : HTMLElement">
              <dt>attribute boolean resetStyleInheritance</dt>
              <dd><strong>Must</strong> <a>reflect</a> the <a href="#markup-shadow-reset-style-inheritance">resetstyleinheritance</a> attribute.</dd>

              <dt>NodeList getDistributedNodes()</dt>
              <dd>
                When invoked, it <strong>must</strong> return result of running the following steps:
                <ol>
                  <li>
                    If the <a>context object</a> is a <a>shadow insertion point</a>:
                    <ol>
                      <li>Return a <a>static</a> <a><code>NodeList</code></a> consisting of nodes in the <a>distributed nodes</a> of the <a>context object</a>.</li>
                    </ol>
                  </li>
                  <li>
                    Otherwise:
                    <ol>
                      <li>Return an empty <a>static</a> <a><code>NodeList</code></a>.</li>
                    </ol>
                  </li>
                </ol>
              </dd>
            </dl>
          </dd>
        </dl>
      </section>

      <section id="extensions-to-event">
        <h3>Extensions to <code>Event</code> Interface</h3>

        <dl class="idl" title="partial interface Event">
          <dt>readonly attribute NodeList path</dt>
          <dd>
            <p>Represents the adjusted event path.</p>
            <p>To maintain encapsulation, the <a title="node">nodes</a> in the <a title="inclusive ancestor tree">inclusive ancestor trees</a> <strong>must</strong> be included in the event path, relative to the <a>node</a> on which <a title="event listener">event listeners</a> would be invoked.</p>
            <p>
              On getting, the attribute <strong>must</strong> return a result that is <a title="processing equivalence">equivalent</a> to running the following steps:
            </p>
            <div class="algorithm">
              <dl>
                <dt>Input</dt>
                <dd><var>PATH</var>, the event path for an event</dd>
                <dd><var>NODE</var>, the <a>node</a> on which event listeners would be invoked</dd>
                <dt>Output</dt>
                <dd><var>RESULT</var>, an adjusted event path for <var>NODE</var></dd>
              </dl>
              <ol>
                <li>Let <var>TREE1</var> be the <a>node tree</a> that <var>NODE</var> <a>participates</a> in</li>
                <li>Let <var>RESULT</var> be the empty ordered list</li>
                <li>
                  For each node, <var>NODE2</var>, in <var>PATH</var>:
                  <ol>
                    <li>Let <var>TREE2</var> be the <a>node tree</a> that <var>NODE2</var> <a>participates</a> in</li>
                    <li>If <var>TREE2</var> is an <a>inclusive ancestor tree</a> of <var>TREE1</var>, add <var>NODE2</var> to <var>RESULT</var></li>
                  </ol>
                </li>
              </ol>
            </div>
            <p>These steps <strong>must</strong> run prior to invoking <a title="event listener">event listeners</a> on any <a>node</a> in <var>PATH</var>.</p>
          </dd>
        </dl>
      </section>
    </section>

    <section id="shadow-dom-example">
      <h2>Shadow DOM Example</h2>

      <p>Bob was asked to turn a simple list of links into a News Widget, which has links organized into two categories: breaking news and just news. The current document markup for the stories looks like this:</p>
      <pre class="example highlight">
&lt;ul class=&quot;stories&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/1&quot;&gt;A story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/2&quot;&gt;Another story&lt;/a&gt;&lt;/li&gt;
    &lt;li class=&quot;breaking&quot;&gt;&lt;a href=&quot;//example.com/stories/3&quot;&gt;Also a story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/4&quot;&gt;Yet another story&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;//example.com/stories/4&quot;&gt;Awesome story&lt;/a&gt;&lt;/li&gt;
    &lt;li class=&quot;breaking&quot;&gt;&lt;a href=&quot;//example.com/stories/5&quot;&gt;Horrible story&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
      </pre>

      <p>To organize the stories, Bob decides to use <strong>shadow DOM</strong>. Doing so will allow Bob to keep the document markup uncluttered, and harnessing the power of insertion point makes sorting stories by class name a very simple task. After getting another cup of <a href="http://en.wikipedia.org/wiki/List_of_coffee_beverages#Green_Eye">Green Eye</a>, he quickly mocks up the following shadow tree, to be hosted by the <code>ul</code> element:</p>
      <pre class="example highlight">
&lt;div class=&quot;breaking&quot;&gt;
    &lt;ul&gt;
        &lt;content select=&quot;.breaking&quot;&gt;&lt;/content&gt; &lt;!-- insertion point for breaking news --&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;other&quot;&gt;
    &lt;ul&gt;
        &lt;content&gt;&lt;/content&gt; &lt;!-- insertion point for the rest of the news --&gt;
    &lt;/ul&gt;
&lt;/div&gt;
      </pre>
      <p>Bob then styles the newborn widget according to comps from the designer by adding this to the shadow tree mockup:</p>
      <pre class="example highlight">
&lt;style&gt;
    div.breaking {
        color: Red;
        font-size: 20px;
        border: 1px dashed Purple;
    }
    div.other {
        padding: 2px 0 0 0;
        border: 1px solid Cyan;
    }
&lt;/style&gt;
      </pre>
      <p>While pondering if his company should start looking for a new designer, Bob converts the mockup to code:</p>
      <pre class="example highlight">
function createStoryGroup(className, contentSelector)
{
    var group = document.createElement('div');
    group.className = className;
    // Empty string in select attribute or absence thereof work the same, so no need for special handling.
    group.innerHTML = '&lt;ul&gt;&lt;content select=&quot;' + contentSelector + '&quot;&gt;&lt;/content&gt;&lt;/ul&gt;';
    return group;
}

function createStyle()
{
    var style = document.createElement('style');
    style.textContent = 'div.breaking { color: Red;font-size: 20px; border: 1px dashed Purple; }' +
        'div.other { padding: 2px 0 0 0; border: 1px solid Cyan; }';
    return style;
}

function makeShadowTree(storyList)
{
    var root = storyList.createShadowRoot();
    root.appendChild(createStyle());
    root.appendChild(createStoryGroup('breaking', '.breaking'));
    root.appendChild(createStoryGroup('other', ''));
}

document.addEventListener('DOMContentLoaded', function() {
    [].forEach.call(document.querySelectorAll('ul.stories'), makeShadowTree);
});
      </pre>

      <p>Well done, Bob! With the cup of coffee still half-full, the work is complete. Recognizing his awesomeness, Bob returns to teaching n00bs the ways of <a href="http://en.wikipedia.org/wiki/World_of_Warcraft">WoW</a>.</p>

      <p>A few months pass.</p>

      <p>It's election time. With Bob at his annual conference, Alice is charged with adding <strong>another</strong>, temporary box to the news widget, filled with election-related stories. Alice studies Bob's code, reads up on the shadow DOM spec and realizes that, thanks to multiple shadow tree support, she doesn't have to touch his code. As usual, her solution is elegant and simple, fitting neatly right under Bob's code:</p>
      <pre class="example highlight">
// TODO(alice): BEGIN -- DELETE THIS CODE AFTER ELECTIONS ARE OVER.
var ELECTION_BOX_REMOVAL_DEADLINE = ...;

function createElectionStyle()
{
    var style = document.createElement('style');
    // TODO(alice): Check designer's desk for hallucinogens.
    style.textContent = 'div.election { color: Magenta; font-size: 24px; border: 2px dotted Fuchsia; }';
    return style;
}

function makeElectionShadowTree(storyList)
{
    var root = storyList.createShadowRoot();
    // Add and style election story box.
    root.appendChild(createElectionStyle());
    root.appendChild(createStoryGroup('election', '.election'));
    // Insert Bob's shadow tree under the election story box.
    root.appendChild(document.createElement('shadow'));
}

if (Date.now() &lt; ELECTION_BOX_REMOVAL_DEADLINE) {
    document.addEventListener('DOMContentLoaded', function() {
        [].forEach.call(document.querySelectorAll('ul.stories'), makeElectionShadowTree);
    });
}
// TODO(alice): END -- DELETE THIS CODE AFTER ELECTIONS ARE OVER.
      </pre>
      <p>Using the <code>shadow</code> element allows Alice to compose Bob's widget <strong>inside</strong> of hers&mdash;without having to change a line of production code. Smiling to herself, Alice realizes that Bob may have come up with a way to keep the document markup clean, but <strong>she</strong> is the one who takes the cake for using shadow tree composition in such a cool way.</p>
    </section>

    <section class="appendix">
      <h2>Acknowledgements</h2>

      <p><span class="vcard">David Hyatt</span> developed <a href="http://dev.w3.org/2006/xbl2/">XBL 1.0</a>, and <span class="vcard">Ian Hickson</span> co-wrote <a href="http://dev.w3.org/2006/xbl2/">XBL 2.0</a>. These documents provided tremendous insight into the problem of functional encapsulation and greatly influenced this specification.</p>

      <p><span class="vcard">Alex Russell</span> and his considerable forethought triggered a new wave of enthusiasm around the subject of shadow DOM and how it can be applied practically on the Web.</p>

      <p><span class="vcard">Dominic Cooney</span>, <span class="vcard">Hajime Morrita</span>, and <span class="vcard">Roland Steiner</span> worked tirelessly to scope the problem of functional encapsulation within the confines of the Web platform and provided a solid foundation for this document.</p>

      <p>The editor would also like to thank <span class="vcard">Alex Komoroske</span>, <span class="vcard">Anne van Kesteren</span>, <span class="vcard">Brandon Payton</span>, <span class="vcard">Brian Kardell</span>, <span class="vcard">Darin Fisher</span>, <span class="vcard">Eric Bidelman</span>, <span class="vcard">Deepak Sherveghar</span>, <span class="vcard">Edward O'Connor</span>, <span class="vcard">Elisée Maurer</span>, <span class="vcard">Elliott Sprehn</span>, <span class="vcard">Erik Arvidsson</span>, <span class="vcard">Glenn Adams</span>, <span class="vcard">Jonas Sicking</span>, <span class="vcard">Malte Ubl</span>, <span class="vcard">Mike Taylor</span>, <span class="vcard">Oliver Nightingale</span>, <span class="vcard">Olli Pettay</span>, <span class="vcard">Rafael Weinstein</span>, <span class="vcard">Richard Bradshaw</span>, <span class="vcard">Ruud Steltenpool</span>, <span class="vcard">Sam Dutton</span>, <span class="vcard">Sergey G. Grekhov</span>, <span class="vcard">Shinya Kawanaka</span>, <span class="vcard">Tab Atkins</span>, <span class="vcard">Takashi Sakamoto</span>, and <span class="vcard">Yoshinori Sano</span> for their comments and contributions to this specification.</p>

      <p>This list is too short. There's a lot of work left to do. Please contribute by reviewing and filing bugs&mdash;and don't forget to ask the editor to add your name into this section.</p>
    </section>

  </body>
</html>
