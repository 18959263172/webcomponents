<!DOCTYPE html>
<html lang="en">
<head>
<title>Shadow DOM</title>
<link rel="stylesheet" href="http://www.w3.org/StyleSheets/TR/base.css" type="text/css">
<link rel="stylesheet" href="../../assets/styles/spec.css" type="text/css">
<script src="../../assets/scripts/bug-assist.js"></script>
<meta name="bug.blocked" content="14978">
<meta name="bug.short_desc" content="[Shadow]: ">
<meta name="bug.product" content="WebAppsWG">
<meta name="bug.component" content="Component Model">
</head>

<body class="draft">

<header>
<h1>Shadow DOM</h1>
<dl>
<dt>This Version</dt>
    <dd><a href="http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html">http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html</a></dd>
<dt>Participate</dt>
    <dd>Discuss on <a href="http://lists.w3.org/Archives/Public/public-webapps/">public-webaps@w3.org</a> (<a href="http://www.w3.org/2008/webapps/">Web Applications Working Group</a>)</dd>
    <dd><a href="https://www.w3.org/Bugs/Public/enter_bug.cgi?comment=&amp;blocked=14978&amp;short_desc=%5BShadow%5D%3A%20&amp;product=WebAppsWG&amp;component=Component%20Model">File bugs</a> (w3.org's <a href="https://www.w3.org/Bugs/Public/">Bugzilla</a>)</dd>
<dt>Status</dt>
    <dd>Living Draft</d>
<dt>Editor</dt>
    <dd>Dimitri Glazkov, Google, &lt;<a href="mailto:dglazkov@chromium.org">dglazkov@chromium.org</a>&gt;</dd>
</dl>
</header>

<section>

<h2>Abstract</h2>

<p>This specification describes a method of establishing and maintaining functional boundaries between DOM subtrees and how these subtrees interact with each other within a document tree, thus enabling better functional encapsulation within DOM.</p>

<h2>About this Document</h2>

<p>All diagrams, examples, notes, are non-normative, as well as sections explicitly marked as non-normative. Everything else in this specification is normative.</p>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this document are to be interpreted as described in <a href="http://dev.w3.org/2006/xbl2/#refsRFC2119">RFC2119</a>. For readability, these words do not appear in all uppercase letters in this specification.</p>

<p>To help with layering and to avoid circular dependencies between various parts of specification, this document consists of three consequtive narratives:
<ol>
    <li>setting up the stage for the specification,</li>
    <li>explaining of the conceptual model and algorithms behind it, and</li>
    <li>expressing this model with DOM interfaces and HTML elements.</li>
</ol>
<p>In a sense, these parts can be viewed as <em>math</em>, which sets up the reasoning environment, <em>physics</em>, which is the theoretical reasoning about the concept, and <em>mechanics</em>, which is the is the practical application of this reasoning.</p>

<p>Any point, at which a conforming UA must make decisions about the state or reaction to the state of the conceptual model, is captured as <a href="http://en.wikipedia.org/wiki/Algorithm">algorithm</a>. The algorithms are defined in terms of processing equivalence. The <dfn id="dfn-processing-equivalence">processing equivalence</dfn> is a constraint imposed on the algorithm implementors, requiring the output of the both UA-implemented and the specified algorithm to be exactly the same for all inputs.</p>

<h2>Terminology</h2>

<dl>
    <dt>DOM</dt>
    <dt>DOM tree</dt>
    <dt>document</dt>
    <dt>element</dt>
    <dt>conforming UA</dt>
</dl>

<h2>Dependencies</h2>

<ul>
    <li>DOM Core specification
    <li>HTML specification
</ul>

</section>

<section>

<h2>Introduction</h2>

<p>Web application developers often encounter the need to provide <dfn id="dfn-encapsulation">encapsulation</dfn> of a DOM structure. Despite being part of one document tree, there are typically many functional fragments of DOM (or <dfn id="dfn-dom-subtree">DOM subtrees</dfn>), as well as assumptions about these fragments operating independently. This type of encapsulation is called <dfn id="dfn-functional-encapsulation">functional encapsulation</dfn>, as opposed to <dfn id="dfn-trust-encapsulation">trust encapsulation</dfn>, which deals limiting information flow based on trust and ensuring security of data and state within an application.</p>

<p><a href="#dfn-functional-encapsulation">Functional encapsulation</a> is primarily concerned with establishing functional boundaries in a document tree. A functional boundary (or just <dfn id="dfn-boundary">boundary</dfn> hereon) is a delineation of functional concerns between two loosely coupled units of functionality.</p>

<h3>Functional Encapsulation Example</h3>
<em>This section is non-normative.</em>

<p>A Web application user interface is commonly composed with several user interface elements (or <dfn id="dfn-widget">widgets</dfn>), each being a DOM subtree. In cases where a widget is tasked with hosting other widgets, the need arises for the widget to understand where its DOM subtree ends and another widget's DOM subtree begins.</p>

<p><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=15065" class=fixme>Add illustration</a></p>

<p>This need for observing the functional <a href="#dfn-boundary">boundaries</a> in a document tree is even larger when a <a href="#dfn-widget">widget</a> is operated on&mdash;added, moved, or removed in the document tree&mdash;by an outside actor, such as the Web application that consumes these widgets. Unless the widget consumer knows exactly how widget's DOM structure is designed, it is impossible for the consumer to reasonably operate on the widget. A typical workaround has been providing alternative means of operation by the widget developer, which, in striving for API consistency quickly extrapolates into a complete set of widget-specific, DOM-like APIs.</p>

<h2>Shadow DOM Subtrees</h2>

<p>This solve this problem at its core, a new abstraction is introduced. The <dfn id="dfn-shadow-dom">shadow DOM</dfn> allows multiple DOM subtrees (in addition to the document tree) to be composed into one larger tree when rendered. The existence of multiple DOM subtrees is enabled by letting any element in the document tree to host one or more additional DOM subtrees. These <dfn id="dfn-shadow-dom-subtree">shadow DOM subtrees</dfn> are governed by a set of rules that establish encapsulation <a href="#dfn-boundary">boundaries</a> while retaining the standard DOM composability semantics.</p>

<p>The encapsulation <a href="#dfn-boundary">boundaries</a> between shadow DOM subtrees are called <dfn id="dfn-shadow-boundary">shadow boundaries</dfn>.</p>

<p><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=15066" class=fixme>Add illustration</a></p>

<p>The elements that host shadow DOM subtrees are called <dfn id="dfn-shadow-host">shadow hosts</dfn>, and the root nodes of the shadow DOM subtrees are called <dfn id="api-shadow-root">shadow roots</dfn>.</p>

<object data="../../assets/images/shadowdom.svg" width=500 height=200></object>

<p>When rendered, the shadow DOM subtree is shown in place of the host element.</p>

<p><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=15067" class=fixme>Add illustration</a></p>

<p>To facilitate composition of host element's children and the shadow DOM subtree, a notion of insertion points is added to the abstraction. An <dfn id="dfn-insertion-point">insertion point</dfn> is a defined location in the shadow DOM subtree, to which the host element's children are transposed when rendering.</p>

<p><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=15068" class=fixme>Add illustration</a></p>

<p>Thus, the encapsulation of a shadow DOM subtree can be viewed as two-fold problem:
<ol>
    <li>the <dfn id="dfn-upper-boundary-encapsulation">upper-boundary encapsulation</dfn>, or governing the boundary between the shadow root and the shadow host; and</li>
    <li>the <dfn id="dfn-lower-boundary-encapsulation">lower-boundary encapsulation</dfn>, or governing the boundary between the insertion points and the shadow host's children.</li>
</ol>

<h3>Upper-boundary Encapsulation</h3>

<p id="dom-scoping">To maintain the upper-boundary encapsulation, the nodes in the <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a> must be share the following characteristics:</p>
<ul>
    <li>The <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/dom-core.html#dom-node-ownerdocument"><code>ownerDocument</code></a> property refers to the document of the <a href="#dfn-shadow-host">shadow host</a></li>
    <li>The nodes <strong>are not</strong> accessible using <a href="#dfn-shadow-host">shadow host</a>'s document <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/dom.html#dom-tree-accessors">DOM tree accessors</a></li>
    <li>The nodes <strong>are</strong> accessible using <a href="#dfn-shadow-root">shadow root</a>'s DOM tree accessor methods</li>
    <li>The <a href="http://www.w3.org/TR/selectors/">selectors</a> <strong>must not</strong> cross the <a href="#dfn-shadow-boundary">shadow boundary</a></li>
</ul>
<p>For convenience, the <a href="dfn-shadow-root">shadow root</a> provides its own set of DOM tree accessor methods. No nodes other than <a href="dfn-shadow-root">shadow root</a> descendants are accessible with these methods.</p>

<p>The <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/dom-core.html#dom-node-parentnode"><code>parentNode</code></a> and <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/dom-core.html#dom-node-parentelement"><code>parentElement</code></a> attributes of the <a href="dfn-shadow-root">shadow root</a> object must always return <code>null</code>.</p>

<h3>Lower-boundary Encapsulation</h3>

<p>To maintain the lower-boundary encapsulation, the distribution of child nodes of the <a href="#dfn-shadow-host">shadow host</a> among the <a href="#dfn-insertion-point">insertion points</a> in the associated <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a> must have the following traits:</p>
<ul>
    <li>The distribution does not affect the state of the document DOM tree or shadow DOM subtrees</li>
    <li>Each insertion point participates in distribution by providing a matching criteria for the child nodes. The <dfn id="dfn-matching-criteria">matching criteria</dfn> determines whether a given node could be distributed to a given insertion point</li>
    <li>The distribution is a result of executing a stable algorithm</li>
    <li>The distribution itself does not change the variables affecting the distribution</li>
    <li>The distribution reoccurs whenever any variable affecting it is changed</li>
</ul>

The <dfn id="dfn-distribution-algorithm">distribution algorithm</dfn> must produce an outcome that is <a href="#dfn-processing-equivalence">equivalent</a> of the outcome of processing these steps:</p>

<dl>
<dt>Input</dt>
<dd><var>POOL</var>, which is a list of DOM nodes.
</dl>

<ol>
    <li><dfn id="#algo-distribution-repeat-outer">Repeat</dfn> for each <a href="#dfn-insertion-point">insertion point</a> in shadow host's <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>, in <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/infrastructure.html#tree-order">tree order</a>:
    <ol>
        <li>Let <var>POINT</var> be the current insertion point</li>
        <li><dfn id="algo-distribution-repeat">Repeat</dfn> for each node in <var>POOL</var>:</li>
        <ol>
            <li>Let <var>NODE</var> be the current node</li>
            <li>If the <var>NODE</var> matches <var>POINT</var>'s <a href="#dfn-matching-criteria">matching criteria</a>:</li>
                <ol>
                    <li>Distribute the <var>NODE</var> to <var>POINT</var></li>
                    <li>Remove <var>NODE</var> from the <var>POOL</var></li>
                </ol></li>
            <li>Otherwise, continue to <a href="#algo-distribution-repeat">repeat</a></li>
        </ol></li>
        <li>Continue to <a href="#algo-distribution-repeat-outer">repeat</a></li>
    </ol></li>
</ol>

<p>When the <a href="dfn-insertion-point">insertion point</a> has no content that is inserted in its place, the fallback content must be used instead. The <dfn id="dfn-fallback-content">fallback content</dfn> is all descendants of the DOM element that represents the insertion point.</p>

<h3>Hosting Multiple Shadow Subtrees</h3>

<p>A <a href="#dfn-shadow-host">shadow host</a> may host more than one <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>. In such cases, the subtrees are stacked in the order of they were added the the host, starting with the subtree added most recently. This set of trees is called a <dfn id="dfn-tree-stack">tree stack</dfn>. The more recently added subtree is called the <dfn id="dfn-younger-tree">younger tree</dfn>, and the less recently added subtree is called the <dfn id="dfn-older-tree">older tree</dfn>. The most recently added subtree is called the <dfn id="dfn-youngest-tree">youngest tree</dfn>.</p>

<p>To facilitate composing multiple shadow subtrees of the same host, a special kind of <a href="#dfn-insertion-point">insertion point</a> is defined. The <dfn id="dfn-shadow-insertion-point">shadow insertion point</dfn> designates a place in the <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>, where an <a href="#dfn-older-tree">older tree</a> is inserted.</p>

<p>The composition is performed with the <dfn id="dfn-tree-composition">tree composition algorithm</dfn>, which must be <a href="#dfn-processing-equivalence">equivalent</a> to processing the following steps:

<ol>
    <li>Let <var>TREE</var> be the <a href="#dfn-youngest-tree">youngest tree</a> in the <a href="#dfn-tree-stack">tree stack</a>
    <li>Let <var>POOL</var> be the list of nodes</li>
    <li>Populate <var>POOL</var> with child nodes of the <a href="#dfn-shadow-host">shadow host</a></li>
    <li>Let <var>POINT</var> be the first encountered <a href="#dfn-shadow-insertion-point">shadow insertion point</a>, in <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/infrastructure.html#tree-order">tree order</a>
    <li><dfn id="algo-composition-repeat">Repeat</dfn> while <var>TREE</var> exists:</li>
    <ol>
        <li>Run the <a href="#dfn-distribution-algorithm">distribution algorithm</a> on the <var>TREE</var>, supplying <var>POOL</var> as input</li>
        <li>If <var>POINT</var> exists:
        <ol>
            <li>Find the next older tree, relative to <var>TREE</var> in the <a href="#dfn-tree-stack">tree stack</a>
            <ol>
                <li>If there is no older tree, <strong>stop</strong>.</li>
                <li>Otherwise:
                <ol>
                    <li>Let <var>TREE</var> be this older tree</li>
                    <li>Assign <var>TREE</var> to the <var>POINT</var></li>
                    <li>Continue to <a href="#algo-composition-repeat">repeat</a></li>
                </ol></li>
            </ol></li>
        </ol></li>
        <li>Otherwise, <strong>stop</strong>.
    </ol></li>
</ol>

<h3>Nested Shadow Subtrees</h3>

<p>Any element in a <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a> can be a <a href="#dfn-shadow-host">shadow host</a>, thus producing nested shadow DOM subtrees. A shadow DOM subtree is <dfn id="dfn-nested-subtree">nested</dfn> when its <a href="#dfn-shadow-host">shadow host</a> is itself a part of a <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>.</p>

<h3>Rendering Shadow DOM Subtrees</h3>

<p><dfn id="dfn-rendering">Rendering</dfn> of <a href="#dfn-shadow-dom-subtree">shadow DOM subtrees</a>, or presenting them visually, is defined as a specialization of rendering <strong>any DOM subtree</strong>, and must happen as these steps:</p>

<ol>
    <li>Run <a href="#dfn-tree-composition-algorithm">tree composition algorithm</a> for the given <a href="#dfn-shadow-host">shadow host</a></li>
    <li>As content of the <a href="#dfn-shadow-host">shadow host</a>, render the <a href="#dfn-youngest-tree">youngest tree</a> as a <strong>any DOM subtree</strong>, with the following <dfn id="dfn-shadow-rendering">shadow rendering</dfn> exceptions:
    <ul>
        <li>Each element that is a <a href="#dfn-shadow-host">shadow host</a> must be <a href="#dfn-rendering">rendered</dfn> accordingly</li>
        <li>In place of each <a href="#dfn-insertion-point">insertion point</a>, process the following <dfn id="dfn-insertion-point-rendering">insertion point rendering</dfn> steps:
        <ol>
            <li>If there are child nodes <a href="#dfn-distribution-algorithm">distributed</a> to this insertion point, for each child node and in the order they were distributed:
            <ol>
                <li>Let <var>CHILD</var> be the child node being rendered</li>
                <li>If <var>CHILD</var> is itself an <a href="#dfn-insertion-point">insertion point</a>, and the tree being rendered is <a href="#dfn-nested-subtree">nested</a>, render them using <a href="#dfn-insertion-point-rendering">insertion point rendering</a> steps</li>
                <li>Otherwise, render <var>CHILD</var> as <strong>any DOM subtree</strong>
            </ol></li>
            <li>Otherwise, render <a href="#dfn-fallback-content">fallback content</a> as <strong>any DOM subtree</strong></li>
        </ol></li>
        <li>In place of each <a href="#dfn-shadow-insertion-point">shadow insertion point</a>:
        <ol>
            <li>If there is the <a href="#dfn-older-tree">older tree</a> in <a href="#dfn-shadow-host">shadow host</a>'s <a href="#dfn-tree-stack">tree stack</a>, render it as as <strong>any DOM subtree</strong>, but with the same <a href="#dfn-shadow-rendering">shadow rendering</a> exceptions.</li>
            <li>Otherwise, render <a href="#dfn-fallback-content">fallback content</a> as <strong>any DOM subtree</strong></li>
        </ol></li>
    </ul></li>
</ol>

<p>This process of <a href="#dfn-rendering">rendering</a> produces a structure that is a composition of several DOM subtrees, including the document tree. The term "<dfn id="dfn-as-rendered">as rendered</dfn>" is used to refer to this structure.</p>

<h3>Shadow DOM Tree Rendering Example</h3>

<p><a class="fixme" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=15173">Add example</a></p>

<h2>Events</h2>

In <a href="#dfn-shadow-dom-subtree">shadow DOM subtrees</a>, the <a href="http://www.w3.org/TR/domcore/#events">DOM Events</a> are allowed to cross the <a href="#dfn-shadow-boundary">shadow boundaries</a> under some conditions.</p>

<p>When an event is fired in a <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>, it either <em>escapes</em> out of the shadow tree during the capture, target, bubble, or default phases or it <em>is stopped</em> at the <a href="shadow-boundary">shadow boundary</a>.</p>

<p>In terms of <a href="http://www.w3.org/TR/domcore/#dispatching-events">DOM event dispatch</a>, this manifests in populating the list of ancestors of the target node with <dfn id="dfn-adjusted-parent">adjusted parent</dfn> nodes, or nodes that appear as parents <a href="#dfn-as-rendered">as rendered</a>. The <dfn id="dfn-parent-calculation-algorithm">parent calculation algorithm</dfn> is used to determine the <a href="#dfn-adjusted-parent">adjusted parent</a> of any given node and create the list of ancestors for event dispatch. This algorithm must be <a href="#dfn-processing-equivalence">equivalent</a> to processing the following steps:</p>

<dl>
<dt>Input</dt>
<dd><var>NODE</var>, a DOM node.</dd>
<dt>Output</dt>
<dd><var>PARENT</var>, a DOM node's <a href="#dfn-adjusted-parent">adjusted parent</a>.</dd>
</dl>
<ol>
    <li>If <var>NODE</var> is currently distributed to an <a href="#dfn-insertion-point">insertion point</a> in a <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>
    <ol>
        <li>Let the <var>PARENT</var> be the <a href="#dfn-insertion-point">insertion point</a> to which the <var>NODE</var> is distributed to</li>
    </ol></li>
    <li>If <var>NODE</var> is a <a href="#dfn-shadow-root">shadow root</a>:
    <ol>
        <li>If <var>NODE</var> is currently assigned to a <a href="#dfn-shadow-insertion-point">shadow insertion point</a>:
        <ol>
            <li>Let the <var>PARENT</var> be the <a href="#dfn-shadow-insertion-point">shadow insertion point</a> to which <var>NODE</var> is assigned to</li>
        </ol></li>
        <li>Otherwise, let the <var>PARENT</var> be the <a href="#dfn-shadow-host">shadow host</a> of the <var>NODE</var>
    </ol></li>
    <li>Otherwise, let <var>PARENT</var> be the node's parent node.</li>
</ol>

<p>In the cases where event escapes the shadow tree, the event's information about the target of the event is adjusted in order to maintain <a href="#dfn-upper-boundary-encapsulation">upper boundary encapsulation</a>.

<h3>Event Retargeting</h3>

<p>Event <dfn id="dfn-retargeting">retargeting</dfn> is a process of computing a <em>relative target</em> for each ancestor of the node at which the event is dispatched.</p>

<p>To help with algorithm description, let's define the direction walking the ancestors of a node as <dfn id="dfn-travsere-up">up</dfn> when traversing from child to parent, and <dfn id="dfn-travsere-down">down</dfn> when traversing from parent to child. In the context of events-related algorithms, all ancestor traversal crosses <a href="#dfn-shadow-boundary">shadow boundaries</a>.</p>

<p>The following <dfn id="dfn-retargeting-algorithm">retargeting algorithm</dfn> must be used to determine relative targets:</p>

<ol>
    <li>Set the relative target of the node at which event is fired to the node itself.</li>
    <li>For each ancestor walking <a href="#dfn-travsere-up">up</a> starting with the node's parent, compute its <dfn id="dfn-relative-target">relative target</dfn>:</li>
        <ol>
            <li>If the node is a <a href="#dfn-shadow-boundary">shadow boundary</a>, Skip it.</li>
            <li>If the previous node was a <a href="#dfn-shadow-boundary">shadow boundary</a>, make the node its own <a href="#dfn-relative-target">relative target</a>.</li>
            <li>Otherwise: use the previous node's <a href="#dfn-relative-target">relative target</a>.</li>
        </ol>
    </li>
</ol>

<p>The retargeting process must occur prior to dispatch of an event.</p>

<p>At the time of event dispatch, for <a href="http://www.w3.org/TR/domcore/#dom-event-capturing_phase">CAPTURING_PHASE</a>, <a href="http://www.w3.org/TR/domcore/#dom-event-at_target">AT_TARGET</a>, and <a href="http://www.w3.org/TR/domcore/#dom-event-bubbling_phase">BUBBLING_PHASE</a>, the <a href="http://www.w3.org/TR/domcore/#event"><code>Event</code></a> object's <a href="http://www.w3.org/TR/domcore/#dom-event-target"><code>target</code></a> and <a href="http://www.w3.org/TR/domcore/#dom-event-currenttarget"><code>currentTarget</code></a> must attributes be set to the <a href="#dfn-relative-target">relative target</a> that was computed for the node along the capturing and bubbling flow.</p>

<p>The event must not be retargeted during the default phase of event dispatch.</p>

<p>Upon completion of the event dispatch, the <a href="http://www.w3.org/TR/domcore/#event"><code>Event</code></a> object's <a href="http://www.w3.org/TR/domcore/#dom-event-target"><code>target</code></a> and <a href="http://www.w3.org/TR/domcore/#dom-event-currenttarget"><code>currentTarget</code></a> are set to the highest ancestor's <a href="#dfn-relative-target">relative target</a>. Since it is possible for a script to hold on to the <code>Event</code> object past the scope of event dispatch, this step is necessary to avoid revealing the nodes in <a href="#dfn-shadow-dom-subtree">shadow DOM subtrees</a>.</p>

<h3>Retargeting <code>relatedTarget</code></h3>

<p>Some events have a <a href="http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-relatedTarget"><code>relatedTarget</code></a> property, which holds a node that's not the event's target, but is related to the event.</p>

<p>For instance, a <code>mouseover</code> event's <a href="http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-relatedTarget"><code>relatedTarget</code></a> may hold the node from which the mouse has moved to event's <code>target</code>. In the case where <code>relatedTarget</code> is in a <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>, the conforming UAs must not leak its actual value outside of this subtree. In cases where both <code>relatedTarget</code> and <code>target</code> are part of the same <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>, the conforming UAs must <em>stop</em> events at the <a href="#dfn-shadow-boundary">shadow boundary</a> to avoid the appearance of spurious <code>mouseover</code> and <code>mouseout</code> events firing from the same node.</p>

<p>Thus, if an event has a <code>relatedTarget</code>, its value and extent of event dispatch must to be adjusted. In general:</p>
<ol>
    <li>If <code>relatedTarget</code> and <code>target</code> are enclosed by a <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>, the event dispatch must be stopped at the <a href="#dfn-shadow-boundary">shadow boundary</a> of this subtree.</li>
    <li>If <code>relatedTarget</code> is separated from <code>target</code> by one or more <a href="#dfn-shadow-boundary">shadow boundaries</a>, it must be retargeted to the boundary that's closest to <code>target</code>.</li>
</ol>

<object data="../../assets/images/related-target-and-shadow-dom.svg" width=400 height=400></object>

<p id="related-target-algorithm">The following algorithm must be used:</p>
<ol>
    <li>Find the <dfn>lowest common ancestor</dfn> of <code>target</code> and <code>relatedTarget</code>.</li>
    <li>If there is none, skip to step 7 in the algorithm.</li>
    <li>If the <a href="#dfn-lowest-common-ancestor">lowest common ancestor</a> is <code>relatedTarget</code>, and it's a <a href="#dfn-shadow-host">shadow  host</a>, make this tree's boundary the <dfn>lowest common boundary</dfn>, and go to step 6 in the algorithm.</li>
    <li>Looking at the ancestors of the <a href="#dfn-lowest-common-ancestor">lowest common ancestor</a>, starting at its parent and walking <a href="#dfn-traversal-up">up</a>, find a <a href="#dfn-shadow-boundary">shadow boundary</a>. This is the <dfn id="dfn-lowest-common-boundary">lowest common boundary</dfn>, the boundary of a <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a> that encloses both <code>target</code> and <code>relatedTarget</code>.
    <li>If the <a href="#dfn-lowest-common-boundary">lowest common boundary</a> is not found, skip to step 7 in the algorithm.</li>
    <li>Limit event dispatch to the descendants of the <a href="#dfn-lowest-common-boundary">lowest common boundary</a>.</li>
    <li>If the <a href="#dfn-lowest-common-boundary">lowest common boundary</a> is still undetermined at this point, set it to be the farthest ancestor of the <code>relatedTarget</code>.</li>
    <li>Starting from <a href="#dfn-lowest-common-boundary">lowest common boundary</a> and walking <a href="#dfn-traversal-down">down</a> ancestors of the <code>relatedTarget</code>, find a <a href="#dfn-shadow-boundary">shadow boundary</a>. This is the <dfn id="dfn-first-divergent-boundary">first divergent boundary</dfn>.</li>
    <li>If <a href="#dfn-first-divergent-boundary">first divergent boundary</a> is not found, stop.</li>
    <li>Set <code>relatedTarget</code> to the parent of the <a href="#dfn-first-divergent-boundary">first divergent boundary</a>.
</ol>

<h3>Retargeting Focus Events</h3>

<p>The <code>focus</code>, <code>DOMFocusIn</code>, <code>blur</code>, and <code>DOMFocusOut</code> events must be treated in the same way as events with a <code>relatedTarget</code>, where the corresponding node that is losing focus as a result of <code>target</code> gaining focus or the node that is gaining focus, and thus causing the blurring of <code>target</code> acts as the related target.</p>

<h3>Events That Are Always Stopped</h3>

<p>Mutation events and <code>selectstart</code> event are always stopped at the nearest <a href="#dfn-shadow-boundary">shadow boundary</a>.</p>

<h3>Event Retargeting Example</h3>

<p>Suppose we have a user interface for a media controller, represented by this DOM tree, composed of both document and the <a href="#dfn-shaow-dom-subtree">shadow DOM subtrees</a>:</p>
<pre class="example html"><code>
&lt;div id=&quot;player&quot;&gt;
    <span class=shadow-boundary>&lt;shadow-boundary&gt;</span>
        &lt;div pseudo=&quot;controls&quot;&gt;
            &lt;button pseudo=&quot;play-button&quot;&gt;
            &lt;input type=&quot;range&quot; pseudo=&quot;timeline&quot;&gt;
                <span class=shadow-boundary>&lt;shadow-boundary&gt;</span>
                    &lt;div pseudo=&quot;slider-thumb&quot;&gt;&lt;/div&gt;
                <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
            &lt;/input&gt;
            &lt;div pseudo=&quot;volume-slider-container&quot;&gt;
                &lt;input type=&quot;range&quot; pseudo=&quot;volume-slider&quot;&gt;
                    <span class=shadow-boundary>&lt;shadow-boundary&gt;</span>
                        &lt;div pseudo=&quot;slider-thumb&quot;&gt;&lt;/div&gt;
                    <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
                &lt;/input&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
&lt;/div&gt;
</code></pre>

<p>Let's have a user position their pointing device over the volume slider's thumb (<code>#player::volume-slider::slider-thumb</code>), thus triggering a <code>mouseover</code> event on that node. For this event, let's pretend it has no associated <code>relatedTarget</code>.</p>

<p>Just before the event is dispatched, we perform <a href="#dfn-retargeting">retargeting</a>:</p>
<ol>
    <li>We set the <a href="#dfn-relative-target">relative target</a> of the thumb node to itself.</li>
    <li>Walking <a href="#dfn-travseral-up">up</a>, we find a <a href="#dfn-shadow-boundary">shadow boundary</a> and skip it.</li>
    <li>Next up is an input (<code>#player::volume-slider</code>), and we set its relative target to itself, since the previous ancestor was a shadow boundary.</li>
    <li>We then walk up to the containing div (<code>#player::volume-slider-container</code>), and use previous ancestor's target -- the input element.</li>
    <li>Walking up one more, we reach the controls panel (<code>#player::controls</code>), and again use input element as relative target per <a href="#dfn-retargeting-algorithm">retargeting algorithm</a>.</li>
    <li>Next, we reach another <a href="#dfn-shadow-boundary">shadow boundary</a> and skip it.</li>
    <li>Finally we walk up to the player element (<code>#player</code>) and set its relative target to itself.</li>
</ol>

<pre class="example html"><code>
<span class=event-ancestor>&lt;div id=&quot;player&quot;&gt; <em>7</em></span>
    <span class="shadow-boundary event-ancestor">&lt;shadow-boundary&gt; <em>6</em></span>
        <span class=event-ancestor>&lt;div pseudo=&quot;controls&quot;&gt; <em>5</em></span>
            &lt;button pseudo=&quot;play-button&quot;&gt;
            &lt;input type=&quot;range&quot; pseudo=&quot;timeline&quot;&gt;
                <span class=shadow-boundary>&lt;shadow-boundary&gt;</span>
                    &lt;div pseudo=&quot;slider-thumb&quot;&gt;&lt;/div&gt;
                <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
            &lt;/input&gt;
            <span class=event-ancestor>&lt;div pseudo=&quot;volume-slider-container&quot;&gt; <em>4</em></span>
                <span class=event-ancestor>&lt;input type=&quot;range&quot; pseudo=&quot;volume-slider&quot;&gt; <em>3</em></span>
                    <span class="shadow-boundary event-ancestor">&lt;shadow-boundary&gt; <em>2</em></span>
                        <span class=event-ancestor>&lt;div pseudo=&quot;slider-thumb&quot;&gt;&lt;/div&gt; <em>1</em></span>
                    <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
                &lt;/input&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
&lt;/div&gt;
</code></pre>

<p>
At the end of this process, we should have the following set of ancestors and relative targets:
</p>
<table>
<thead>
<tr>
    <th>Ancestor</th>
    <th>Relative Target</th>
</tr>
</thead>
<tbody>
<tr>
    <td><code>...</code></td>
    <td><code>div#player</code></td>
</tr>
<tr>
    <td><code>div#player</code></td>
    <td><code><strong>div#player</strong></code></td>
</tr>
<tr>
    <td><code>div#player::controls</code></td>
    <td><code>div#player::controls::volume-slider</code></td>
</tr>
<tr>
    <td><code>div#player::volume-slider-container</code></td>
    <td><code>div#player::controls::volume-slider</code></td>
</tr>
<tr>
    <td><code>div#player::controls::volume-slider</code></td>
    <td><code><strong>div#player::controls::volume-slider</strong></code></td>
</tr>
<tr>
    <td><code>div#player::controls::volume-slider::slider-thumb</code></td>
    <td><code><strong>div#player::controls::volume-slider::slider-thumb</strong></code></td>
</tr>
</tbody>
</table>

<p>After we dispatch the <code>mouseover</code> event using these newly computed relative targets, the user decides to move their pointing device over the thumb of the timeline
(<code>#player::timeline::slider-thumb</code>). This triggers both a <code>mouseout</code> event for the volume slider thumb and the <code>mouseover</code> event for the timeline thumb.</p>

<p>Let's study how the <code>relatedTarget</code> value of the volume thumb's <code>mouseout</code> event is affected and whether event escapes out of the player. For this event, the <code>relatedTarget</code> is the timeline thumb (<code>#player::timeline::slider-thumb</code>).</p>

<ol>
    <li>We find lowest common ancestor of timeline thumb and volume slider thumb: the controls panel (<code>#player::controls</code>).</li>
    <li>Walking <a href="#dfn-traversal-up">up</a>, we look for a <a href="#dfn-shadow-boundary">shadow boundary</a>, and find one just above. This is the lowest common boundary.</li>
    <li>Given that the lowest common boundary exists, we limit event dispatch to the descendants of this boundary.</li>
    <li>Starting from the lowest common boundary, we walk <a href="#dfn-traversal-down">down</a> the ancestors of the timeline thumb, looking for a <a href="shadow-boundary">shadow boundary</a>. We find it just below the timeline (<code>#player::timeline</code>). This is the <a href="#dfn-first-divergent-boundary">first divergent boundary</a>.</li>
    <li>We adjust <code>relatedTarget</code> to be the parent of the first divergent boundary, the timeline (<code>#player::timeline</code>). We are now ready to dispatch this event.</li>
</ol>

<pre class="example html"><code>
&lt;div id=&quot;player&quot;&gt;
    <span class="shadow-boundary lowest-common-boundary">&lt;shadow-boundary&gt;<em> &mdash; lowest common boundary</em></span>
        &lt;div pseudo=&quot;controls&quot;&gt;
            &lt;button pseudo=&quot;play-button&quot;&gt;
            &lt;input type=&quot;range&quot; pseudo=&quot;timeline&quot;&gt;
                <span class="shadow-boundary first-divergent-boundary">&lt;shadow-boundary&gt;<em>  &mdash; first divergent boundary</em></span>
                    &lt;div pseudo=&quot;slider-thumb&quot;&gt;&lt;/div&gt;
                <span class="shadow-boundary first-divergent-boundary">&lt;/shadow-boundary&gt;</span>
            &lt;/input&gt;
            &lt;div pseudo=&quot;volume-slider-container&quot;&gt;
                &lt;input type=&quot;range&quot; pseudo=&quot;volume-slider&quot;&gt;
                    <span class=shadow-boundary>&lt;shadow-boundary&gt;</span>
                        &lt;div pseudo=&quot;slider-thumb&quot;&gt;&lt;/div&gt;
                    <span class=shadow-boundary>&lt;/shadow-boundary&gt;</span>
                &lt;/input&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    <span class="shadow-boundary lowest-common-boundary">&lt;/shadow-boundary&gt;</span>
&lt;/div&gt;
</code></pre>

<h2>Styles</h2>

<p>To enforce <a href="#dfn-lower-boundary-encapsulation">lower-boundary encapsulation</a>, <a href="http://www.w3.org/TR/CSS2/syndata.html#rule-sets">CSS rules</a> declared by the document do not apply in a <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>, unless the <dfn id="dfn-apply-author-styles">apply-author-styles</dfn> flag is set for this subtree. The flag signals that document CSS rules are applicable in the <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>.

<p>Conversely, to enforce <a href="#dfn-upper-boundary-encapsulation">upper-boundary encapsulation</a>, <a href="http://www.w3.org/TR/CSS2/syndata.html#rule-sets">CSS rules</a> from a <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a> do not apply to the nodes, distributed to the <a href="#dfn-insertion-point">insertion points</a>.

<p>The <dfn id="dfn-rule-applicability-algorithm">rule applicability algorithm</dfn> is used to determine whether any given rule is applicable to any DOM node, and it <strong>must</strong> be equivalent to processing the following steps:</p>

<dl>
<dt>Input</dt>
<dd><var>RULE</var>, a CSS rule whose applicability is being determined</dd>
<dd><var>NODE</var>, a DOM node</dd>
<dt>Output</dt>
<dd>Whether <var>RULE</var> must be applied to <var>NODE</var></a>.
</dl>
<ol>
    <li>If <var>RULES</var> is not an <a href="http://www.w3.org/TR/CSS2/cascade.html">author style</a>, the rule <strong>is</strong> applicable to <var>NODE</var>.</li>
    <li>Otherwise:
    <ol>
        <li>Let <var>TREE</var> be the DOM subtree to which <var>NODE</var> belongs. The <var>TREE</var> is then the document tree, a <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>, or some disconnected tree</li>
        <li>If <var>TREE</var> is a disconnected tree, the rule <strong>is not</strong> applicable to <var>NODE</var></li>
        <li>Otherwise, if <var>TREE</var> is a <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>:
        <ol>
            <li>If <var>TREE</var> has the <a href="#dfn-apply-author-styles">apply-author-styles</a> flag is set for <var>TREE</var>, <var>RULE</var> <strong>is</strong> applicable to <var>NODE</var></li>
            <li>Otherwise, if <var>RULE</var> is declared with a <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/semantics.html#the-style-element"><code>style</code></a> element:
            <ol>
                <li>Let <var>STYLE</var> be this style element</li>
                <li>If <var>STYLE</var> has a <code>scoped</code> attribute and <var>STYLE</var> is in <var>TREE</var>, then <var>RULE</var> <strong>is</strong> applicable to <var>NODE</var></li>
                <li>Otherwise, <var>RULE</var> <strong>is not</strong> applicable to <var>NODE</var>
            </ol></li>
        </ol>
        <li>Otherwise, the rule <strong>is</strong> applicable to <var>NODE</var>
    </ol></li>
</ol>

<p>In a document that contains <a href="#dfn-shadow-dom-subtree">shadow DOM subtrees</a>, the CSS properties <strong>must</strong> be inherited from parent nodes, produced using <a href="#dfn-parent-calculation-algorithm">parent calculation algorithm</a>. This requirement has the following effects:</p>
<ul>
    <li>the styles of the <a href="#dfn-shadow-host">shadow host</a> are inherited by the children of the <a href="#dfn-shadow-root">shadow root</a></li>
    <li>the styles of the <a href="#dfn-insertion-point">insertion point</a> node are inherited by those child nodes of the <a href="#dfn-shadow-host">shadow host</a> that are distributed to this <a href="#dfn-insertion-point">insertion point</a></li>
    <li>the styles of the <a href="#dfn-shadow-insertion-point">shadow insertion point</a> node are inherited by the child nodes of the <a href="#dfn-shadow-root">shadow root</a> of the <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>, assigned to this <a href="#dfn-shadow-insertion-point">shadow insertion point</a></li>
</ul>

<h3 id="selector-fragment">Selector Fragment</h3>

<p>A <dfn id="dfn-selector-fragment">selector fragment</dfn> is indeed a fragment in the <a href="http://www.w3.org/TR/css3-selectors">selector</a> <code>(shadow-host)>(fragment)</code>, where <code>(shadow-host)</code> is a selector that uniquely identifies the <a href="#dfn-shadow-host">shadow host</a>, and <code>(fragment)</code> is the <a href="#dfn-selector-fragment">selector fragment</a>.</p>

<p>A valid selector fragment fragment may contain:</p>

<ul>
    <li>A <a href="http://www.w3.org/TR/css3-selectors/#type-selectors">type selector</a> or a <a href="http://www.w3.org/TR/css3-selectors/#universal-selector">universal selector</a></li>
    <li><a href="http://www.w3.org/TR/css3-selectors/#class-html">class selector(s)</a></li>
    <li>An <a href="http://www.w3.org/TR/css3-selectors/#id-selectors">ID selector</a></li>
    <li><a href="http://www.w3.org/TR/css3-selectors/#attribute-selectors">attribute selector(s)</a></li>
    <li>the following <a href="http://www.w3.org/TR/css3-selectors/#pseudo-classes">pseudo-class selector(s)</a>:
        <ul>
            <li><code>:link</code></li>
            <li><code>:visited</code></li>
            <li><code>:target</code></li>
            <li><code>:enabled</code></li>
            <li><code>:disabled</code></li>
            <li><code>:checked</code></li>
            <li><code>:indeterminate</code></li>
            <li><code>:nth-child()</code></li>
            <li><code>:nth-last-child()</code></li>
            <li><code>:nth-of-type()</code></li>
            <li><code>:nth-of-last-type()</code></li>
            <li><code>:first-child</code></li>
            <li><code>:last-child</code></li>
            <li><code>:first-of-type</code></li>
            <li><code>:last-of-type</code></li>
            <li><code>:only-of-type</code></li>
        </ul>
    </li>
</ul>

<p>If any other types of selectors are present the <a href="dfn-selector-fragment">selector fragment</a>, the fragment must be considered invalid.</p>

<p>A conforming UAs must consider a node as <dfn id="dfn-content-matching">matching</dfn> a selector fragment in the context of a given <a href="#dfn-shadow-host">shadow host</a>, if it both:
<ol>
    <li>is a child node of the shadow host; and</li>
    <li>matches the specified selector fragment.</li>
</ol>

</section>

<section>

<h2>Elements and DOM Objects</h2>

<h3><code>ShadowRoot</code> Object</h3>

<p>The <dfn id="api-shadow-root-object"><code>ShadowRoot</code></dfn> object represents the <a href="#api-shadow-root">shadow root</a>.</p>
    
<pre><code>[Constructor(in HTMLElement element) raises (DOMException)]
interface <dfn id="api-shadow-root">ShadowRoot</a> : <a href="http://www.w3.org/TR/domcore/#node">Node</a> {
    <a href="http://www.w3.org/TR/domcore/#element">Element</a> <a href="#api-shadow-root-get-element-by-id">getElementById</a>(in DOMString elementId);
    <a href="http://www.w3.org/TR/domcore/#nodelist">NodeList</a> <a href="#api-shadow-root-get-elements-by-class-name">getElementsByClassName</a>(in DOMString tagName);
    <a href="http://www.w3.org/TR/domcore/#nodelist">NodeList</a> <a href="#api-shadow-root-get-elements-by-tag-name">getElementsByTagName</a>(in DOMString className);
    <a href="http://www.w3.org/TR/domcore/#nodelist">NodeList</a> <a href="#api-shadow-root-get-elements-by-tag-name-ns">getElementsByTagNameNS</a>(DOMString namespace, DOMString localName);
    attribute bool <a href="#api-shadow-root-apply-author-styles">applyAuthorStyles</a>;
    readonly attribute Element <a href="#api-shadow-root-host">host</a>;
}
ShadowRoot implements <a href="http://dev.w3.org/2006/webapi/selectors-api/#nodeselector">NodeSelector</a>;
</code></pre>

<h4><code>ShadowRoot</code> Attributes</h4>

<dl>
<dt id="api-shadow-root-apply-author-styles"><code>applyAuthorStyles</code> of type <code>bool</code></dt>
<dd>Represents the <a href="#dfn-apply-author-styles">apply-author-styles</a> flag and indicates whether or not the rules in <a href="http://www.w3.org/TR/CSS2/cascade.html">author styles</a> associated with the element's document apply to the shadow DOM subtree. If <code>false</code> (default value), the author styles are applied to the shadow DOM subtree. If <code>true</code>, they do not.</dd>
<dt id="api-shadow-root-host"><code>host</code> of type <code>Element</code>, readonly</dt>
<dd>refers back to the shadow host. This value is never <code>null</code>.</dd>
</dl>

<h4><code>ShadowRoot</code> Methods</h4>

<dl>
<dt><code>constructor</code></dt>
<dd>
    Creates new shadow root and associates it with the shadow host.
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Type</th>
                <th>Nullable</th>
                <th>Optional</th>
                <th>Description</th>
            </tr>
        </thead>
            <tr>
                <td><dfn id="api-shadow-root-constructor-element"><code>element</code></dfn></td>
                <td><a href="http://www.w3.org/TR/domcore/#element"><code>Element</code></a></td>
                <td>No</td>
                <td>No</td>
                <td>Element that will be hosting this instance of the shadow DOM subtree.</td>
            </tr>
        <tbody>
        </tbody>
    </table>
    <div>
        <em>Exceptions:</em>
        <dl>
            <dt><a href="http://www.w3.org/TR/domcore/#dom-domexception-hierarchy_request_err"><code>HIERARCHY_REQUEST_ERR</code></a></dt>
            <dd>Thrown when the <code>element</code> parameter is not a valid <a href="http://www.w3.org/TR/domcore/#element"><code>Element</code></a>.
        </dl>
    </div>
    <div>
        <em>Returns: a new <code>ShadowRoot</code> instance.</em>
    </div>
</dd>
<dt id="api-shadow-root-get-element-by-id"><code>getElementById</code></dt>
<dd>Behaves exactly like <a href="http://www.w3.org/TR/domcore/#dom-document-getelementbyid">document.getElementById</a>, except <a href="#dom-scoping">scoped</a> to the shadow DOM subtree.</dd>
<dt id="api-shadow-root-get-elements-by-class-name"><code>getElementsByClassName</code></dt>
<dd>Behaves exactly like <a href="http://www.w3.org/TR/domcore/#dom-document-getelementsbyclassname">document.getElementsByClassName</a>, except <a href="#dom-scoping">scoped</a> to the shadow DOM subtree.</dd>
<dt id="api-shadow-root-get-elements-by-tag-name"><code>getElementsByTagName</code></dt>
<dd>Behaves exactly like <a href="http://www.w3.org/TR/domcore/#dom-document-getelementsbytagname">document.getElementsByTagName</a>, except <a href="#dom-scoping">scoped</a> to the shadow DOM subtree.</dd>
<dt id="api-shadow-root-get-elements-by-tag-name-ns"><code>getElementsByTagNameNS</code></dt>
<dd>Behaves exactly like <a href="http://www.w3.org/TR/domcore/#dom-document-getelementsbytagnamens">document.getElementsByTagNameNS</a>, except <a href="#dom-scoping">scoped</a> to the shadow DOM subtree.</dd>
</dl>


<h3>The <code>content</code> element</h3>

<p>The <dfn id="dfn-content-element"><code>content</code></dfn> element represents an <a href="#dfn-insertion-point">insertion point</a> in the <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>.</p>

<dl>
<dt>Context</dt>
<dd>Where <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#flow-content-0">flow content</a> is expected.</dd>
<dt>Content model</dt>
<dd><a href="http://dev.w3.org/html5/spec/Overview.html#metadata-content">Metadata content</a></dd>
<dt>Children</dt>
<dd>Anything as <a href="#dfn-fallback-content">fallback content</a></dd>
<dt>Content attributes</dt>
<dd><a href="http://dev.w3.org/html5/spec/Overview.html#global-attributes">Global attributes</a></dd>
<dd>
    <dl>
<!--    <dt id="markup-content-apply-shadow-styles"><code>apply-shadow-styles</code>, a <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/common-microsyntaxes.html#boolean-attribute">boolean attribute</a></dt>
    <dd>indicates whether or not the rules in the scoped styles, defined in shadow DOM subtree are applied to the host element's children that are inserted in place of this <code>content</code> element. If present, the styles are applied.</dd> -->
    <dt id="markup-content-select"><code>select</code>, a <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/common-microsyntaxes.html#set-of-space-separated-tokens">set of space-separated tokens</a></dt>
    <dd>
        defines the <a href="#dfn-matching-criteria">matching criteria</a> for distributing child nodes of the <a href="#dfn-host-element">host element</a>. Each token must be a valid <a href="#dfn-selector-fragment">selector fragment</a>. If any token is invalid, the entire value of the <code>select</code> attribute is considered invalid.
    </dd>
    </dl>
</dd>
<dt>DOM Interface</dt>
<dd>
    <pre><code>interface <dfn id="api-html-content-element">HTMLContentElement</a> : <a href="http://dev.w3.org/html5/spec/Overview.html#htmlelement">HTMLElement</a> {<!--    attribute bool <a href="#api-html-content-element-apply-shadow-styles">applyShadowStyles</a>; -->
    attribute <a href="http://dvcs.w3.org/hg/domcore/raw-file/2d8624c7ec02/dom-core.html#interface-domtokenlist">DOMTokenList</a> <a href="#api-html-content-element-select">select</a>;
}
    </code></pre>
    <dl>
    <dt>Attributes</dt>
    <dl>
<!--        <dt id="api-html-content-element-apply-shadow-styles"><code>applyShadowStyles</code> of type <code>bool</code></dt>
        <dd>Must <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/common-dom-interfaces.html#reflect">reflect</a> the <a href="#markup-content-apply-shadow-styles">apply-shadow-styles</a> attribute.</dd> -->
        <dt id="api-html-content-element-select"><code>select</code> of type <code>DOMTokenList</code></dt>
        <dd>
            <dd>Must <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/common-dom-interfaces.html#reflect">reflect</a> the <a href="#markup-content-select">select</a> attribute.</dd>
        </dd>
    </dd>
    </dl>
    </dl>
</dl>


<h3>The <code>shadow</code> element</h3>

<p>The <dfn id="dfn-shadow-element"><code>shadow</code></dfn> element represents an <a href="#dfn-shadow-insertion-point">shadow insertion point</a> in a <a href="#dfn-shadow-dom-subtree">shadow DOM subtree</a>.</p>

<dl>
<dt>Context</dt>
<dd>Where <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#flow-content-0">flow content</a> is expected.</dd>
<dt>Content model</dt>
<dd><a href="http://dev.w3.org/html5/spec/Overview.html#metadata-content">Metadata content</a></dd>
<dt>Children</dt>
<dd>Anything as <a href="#dfn-fallback-content">fallback content</a></dd>
<dt>Content attributes</dt>
<dd><a href="http://dev.w3.org/html5/spec/Overview.html#global-attributes">Global attributes</a></dd>
<dt>DOM Interface</dt>
<dd>
    <pre><code>interface <dfn id="api-html-shadow-element">HTMLShadowElement</a> : <a href="http://dev.w3.org/html5/spec/Overview.html#htmlelement">HTMLElement</a> {
}
    </code></pre>
    </dl>
</dl>

</section>

<h2>Acknowledgements</h2>

<p>David Hyatt developed <a href="http://dev.w3.org/2006/xbl2/">XBL 1.0</a>, and Ian Hickson co-wrote <a href="http://dev.w3.org/2006/xbl2/">XBL 2.0</a>. These documents provided tremendous insight into the problem of functional encapsulation and greatly influenced this specification.</p>

<p>Alex Russell and his considerable forethought triggered a new wave of enthusiasm around the subject of shadow DOM and how it can be applied practically on the Web.</p>

<p>Dominic Cooney, Hajime Morrita, and Roland Steiner worked tirelessly to scope the problem of functional encapsulation within the confines of the Web platform and provided a solid foundation for this document.</p>

<p>The editor would also like to thank  Alex Komoroske, Darin Fisher, Erik Arvidsson, Hayato Ito, Jonas Sicking, Rafael Weinstein, and Tab Atkins for their comments and contributions to this specification.</p>

<p>This list is too short. There's a lot of work left to do. Please contribute by reviewing and filing bugs&mdash;and don't forget to ask the editor to add your name into this section.</p>

</body>
</html>
